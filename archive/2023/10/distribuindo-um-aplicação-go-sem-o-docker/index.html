<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Distribuindo um aplicação Go sem o Docker | Fabio Ribeiro</title>
<meta name=keywords content="go,docker,programming,linux"><meta name=description content="Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.
A grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho docker-compose.yaml.
Dependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina."><meta name=author content><link rel=canonical href=https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://fabioribeiro.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fabioribeiro.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fabioribeiro.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://fabioribeiro.dev/apple-touch-icon.png><link rel=mask-icon href=https://fabioribeiro.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-QDGB5VNSFZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QDGB5VNSFZ")}</script><meta property="og:url" content="https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/"><meta property="og:site_name" content="Fabio Ribeiro"><meta property="og:title" content="Distribuindo um aplicação Go sem o Docker"><meta property="og:description" content="Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.
A grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho docker-compose.yaml.
Dependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-27T20:00:00+02:00"><meta property="article:modified_time" content="2023-10-27T20:00:00+02:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="Distribuindo um aplicação Go sem o Docker"><meta name=twitter:description content="Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.
A grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho docker-compose.yaml.
Dependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fabioribeiro.dev/posts/"},{"@type":"ListItem","position":2,"name":"Distribuindo um aplicação Go sem o Docker","item":"https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Distribuindo um aplicação Go sem o Docker","name":"Distribuindo um aplicação Go sem o Docker","description":"Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.\nA grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho docker-compose.yaml.\nDependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina.\n","keywords":["go","docker","programming","linux"],"articleBody":"Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.\nA grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho docker-compose.yaml.\nDependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina.\nNesse artigo, apresento um compilado de como distribuir a sua aplicação para ser executada diretamente no servidor, por exemplo na sua instância AWS EC2, Google Compute Engine, e quem sabe talvez no seu droplet na Digital Ocean (no final do artigo compartilho um cupom de crédito para você brincar).\nTudo será apresentado em passos que serão incrementais, o empacotamento de uma aplicação em Golang, a preparação das dependências requeridas, a execução, e finalizamos com a atualização e tempo de inatividade.\nDe forma simplificada, uma aplicação será desenvolvida, e para cada mudança, novas tags serão criadas, e iremos focar o empacotamento e distribuição usando Ubuntu Linux (server). Ao final deixo o link onde você encontrará o projeto completo.\nA aplicação Antes de tudo, precisaremos de uma aplicação,e ela guardará os nomes dos filmes e seu dia de lançamento. Na parte que cabe ao banco de dados, eles serão armazenados em um banco de dados em arquivo, e é requerido que seja definida uma variável de ambiente chamada MOVIES_DB_PATH, onde contém a localização deste arquivo.\nVamos para a aplicação em si (de momento não se preocupe com as libs usadas, tudo estará no repositório no final do artigo):\npackage main import ( \"context\" \"os\" \"os/signal\" \"path/filepath\" \"time\" \"github.com/labstack/echo/v4\" bolt \"go.etcd.io/bbolt\" \"github.com/faabiosr/go-movies-demo/internal/movies\" ) const ( appAddr = \"0.0.0.0:8000\" appName = \"moviez\" dbName = \"catalog.db\" dbPathEnv = \"MOVIES_DB_PATH\" ) const timeout = 10 * time.Second func main() { e := echo.New() if os.Getenv(dbPathEnv) == \"\" { e.Logger.Fatalf(\"env '%s' was not defined\", dbPathEnv) } dbPath := filepath.Join(os.Getenv(dbPathEnv), dbName) // Database connect db, err := bolt.Open(dbPath, 0o600, nil) if err != nil { e.Logger.Fatal(err) } ds := movies.NewDatasource(db) // API Resources movies.Routes(e.Group(\"/movies\"), ds) // Start server e.Logger.Infof(\"%s service\", appName) go func() { if err := e.Start(appAddr); err != nil { e.Logger.Info(\"shutting down the service\") } }() // Graceful shutdown quit := make(chan os.Signal, 1) signal.Notify(quit, os.Interrupt) \u003c-quit ctx, cancel := context.WithTimeout(context.TODO(), timeout) defer cancel() if err := e.Shutdown(ctx); err != nil { e.Logger.Fatal(err) } } Note o ponto que informamos anteriormente, a aplicação necessita da variável de ambiente MOVIES_DB_PATH:\npackage main const ( dbName = \"catalog.db\" dbPathEnv = \"MOVIES_DB_PATH\" ) func main() { dbPath := filepath.Join(os.Getenv(dbPathEnv), dbName) // Database connect db, err := bolt.Open(dbPath, 0o600, nil) Agora que temos a aplicação de exemplo, é hora de compilar, e é bem simples, o resultado do comando abaixo será um binário com o nome de movies:\ngo build -o movies ./cmd/movies Com o binário em mãos, já podemos copiar e executar no servidor.\nMOVIES_DB_PATH=/tmp ./movies Pronto é isso! Guia finalizado!\nWTF?\nOK, calma, calma!\nMesmo com o binário criado, a distribuição não é fácil, copiar para o servidor todas as vezes que houver uma nova atualização e executar manualmente pode tornar-se complexo e chato.\nVale ressaltar que não há uma forma consistente para a instalação, e não há como evitar que seja usada outra pasta no servidor, tornando o processo difícil de controlar e passível a erros.\n2. Empacotando o binário Sabendo que a aplicação será executada em um Ubuntu Linux, temos a possibilidade de distribuir como um pacote Debian (deb), ou até mesmo como snap, mas neste exemplo iremos focar no Debian.\nEmpacotar como .deb nos dá algumas vantagens, como:\nPoder controlar a versão do pacote. Executar scripts antes e depois da instalação/remoção do pacote. Adicionar arquivos extras. Preparar um pacote Debian “na mão”, não é uma tarefa muito simples, e para facilitar a nossa vida vamos usar o GoReleaser, essa ferramenta maravilhosa, que internamente faz uso da é nFPM, responsável por criar pacotes Linux. Também é importante dizer que o GoReleaser não só nos ajuda a criar os pacotes Debian, mas também pacotes para Windows, MacOS, RPM, APK e muito mais.\nEm nosso projeto, vamos definir o arquivo .goreleaser.yaml, que contém as informações do pacote a ser gerado, atente-se para seção compartilhada abaixo e note que em formats foi definido o .deb:\nnfpms: - id: movies package_name: movies file_name_template: \"{{ .ConventionalFileName }}\" description: Manages movie collection through API license: MIT formats: - deb Adicionalmente, foi configurado o Github Workflows onde contém os passos para compilar e distribuir em .deb, e o resultado é esse:\nTodas as versões criadas estarão em releases.\nPronto! Agora sim temos um maior controle sobre o versionamento e distribuição da aplicação. De maneira simples e consistente podemos instalar em qualquer distro baseada em Debian.\n3. Lidando com dependências (banco de dados em arquivo) Anteriormente foi mencionado que a aplicação necessita de uma pasta onde o banco de dados será criado, a pasta elegida será em /var/lib/movies-demo, e para a criá-la vamos usar alguns dos hooks que pacote Debian nos fornece:\npostinst (post-install.sh): é executado após instalar ou atualizar um pacote, esse hook ficará responsável por criar a pasta definida acima e também o usuário/grupo dessa pasta (é recomendável que sempre tenha um usuário/grupo, ficando isolado dos demais).\n#!/bin/sh set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo if [ \"$1\" = \"configure\" ]; then # creating user and group adduser --quiet \\ --system \\ --home /nonexistent \\ --no-create-home \\ --disabled-password \\ --group \"$MOVIES_USER\" # creating database folder if [ ! -d $MOVIES_DB_PATH ]; then mkdir -p $MOVIES_DB_PATH chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH fi exit 0 fi Da mesma maneira que temos o postinst, também temos um hook para quando removemos o pacote.\npostrm (post-remove-sh): é executado quando removemos um pacote, e removerá a pasta apenas quando o arquivo de catalog.db não existir.\n#!/bin/sh set -e MOVIES_DB_PATH=/var/lib/movies-demo if [ \"$1\" = \"remove\" ]; then if [ -f \"$MOVIES_DB_PATH/catalog.db\" ]; then echo \"Database file found and won't be removed.\" \u003e\u00262 else echo \"Removing database folder.\" \u003e\u00262 rm -fr $MOVIES_DB_PATH fi exit 0 fi Scripts prontos, agora é só fazer a inclusão deles no .goreleaser.yaml e quando empacotar e instalar a aplicação novamente, a pasta será criada:\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -46,6 +46,9 @@ nfpms: license: MIT formats: - deb + scripts: + postinstall: \"env/debian/post-install.sh\" + postremove: \"env/debian/post-remove.sh\" 4. Rodando a aplicação em background como um serviço (systemd) A pasta já está pronta, mas a execução pela linha de comando continua sendo manual, e para resolver essa questão, vamos executar a aplicação em background como um serviço. Para isso tiraremos proveito do systemd, que já vem instalado no Ubuntu Linux.\nEm poucas palavras, o systemd é um conjunto de blocos de construção para uma sistema Linux, ele fornece um gerenciador de sistema e serviço, e é justamente do segundo ponto que necessitamos.\nPara um serviço é requerido que seja criado um arquivo onde contém as referências para um recurso que o sistema saberá como operar e gerenciar, chamado de unit.\nO unit que usaremos é o service, que descreve como gerenciar um serviço ou aplicação no servidor:\nmovies.service:\n[Unit] Description=Manages movie collection through API Documentation=\"https://github.com/faabiosr/go-movies-demo\" [Service] EnvironmentFile=/etc/default/movies ExecStart=/usr/bin/movies Restart=on-failure User=movies-demo Group=movies-demo KillSignal=SIGINT [Install] WantedBy=multi-user.target Na seção Service:\nEnvironmentFile: arquivo que contém as variáveis de ambiente. ExecStart: caminho do binário. User/Group: usaremos o mesmo criado anteriormente. Precisaremos agora criar um arquivo que contém a variável de ambiente usada pela aplicação:\nmovies.conf:\nMOVIES_DB_PATH=\"/var/lib/movies-demo\" Uma vez finalizada a criação dos arquivos necessários para o systemd, é imprescindível atualizar os hooks do debian para que o mesmo seja ativado e incializado após a instalação:\npostint (post-install.sh): ativa o serviço se não foi ativo, e inicia ou reinicia caso já esteja rodando.\ndiff --git a/env/debian/post-install.sh b/env/debian/post-install.sh --- a/env/debian/post-install.sh +++ b/env/debian/post-install.sh @@ -4,6 +4,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo +MOVIES_SERVICE=movies.service if [ \"$1\" = \"configure\" ]; then # creating user and group @@ -20,5 +21,25 @@ if [ \"$1\" = \"configure\" ]; then chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH fi - exit 0 + # enable systemd service + deb-systemd-helper unmask $MOVIES_SERVICE \u003e/dev/null || true + + if deb-systemd-helper --quiet was-enabled $MOVIES_SERVICE; then + deb-systemd-helper enable $MOVIES_SERVICE \u003e/dev/null || true + else + deb-systemd-helper update-state $MOVIES_SERVICE \u003e/dev/null || true + fi + + # starting service + if [ -d /run/systemd/system ]; then + systemctl --system daemon-reload \u003e/dev/null || true + + if [ -n \"$2\" ]; then + _dh_action=restart + else + _dh_action=start + fi + + deb-systemd-invoke $_dh_action $MOVIES_SERVICE \u003e/dev/null || true + fi fi postrm (post-remove.sh): a nova adição irá reiniciar o serviço do próprio systemd, e o serviço só será removido caso o usuário opte por uma remoção completa.\ndiff --git a/env/debian/post-remove.sh b/env/debian/post-remove.sh --- a/env/debian/post-remove.sh +++ b/env/debian/post-remove.sh @@ -3,6 +3,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo +MOVIES_SERVICE=movies.service if [ \"$1\" = \"remove\" ]; then if [ -f \"$MOVIES_DB_PATH/catalog.db\" ]; then @@ -12,5 +13,16 @@ if [ \"$1\" = \"remove\" ]; then rm -fr $MOVIES_DB_PATH fi - exit 0 + # disabling service + if [ -d /run/systemd/system ]; then + systemctl --system daemon-reload \u003e/dev/null || true + fi + + deb-systemd-helper mask $MOVIES_SERVICE \u003e/dev/null || true +fi + +if [ \"$1\" = \"purge\" ]; then + # disabling service + deb-systemd-helper purge $MOVIES_SERVICE \u003e/dev/null || true + deb-systemd-helper unmask $MOVIES_SERVICE \u003e/dev/null || true fi Adicionalmente criamos o prerm hook, que é executado antes de remover o pacote, e será ele responsável por finalizar a execução da aplicação, assim removemos o pacote de forma segura:\nprerm (pre-remove.sh):\n#!/bin/sh set -e MOVIES_SERVICE=movies.service # stopping service if [ -d /run/systemd/system ]; then deb-systemd-invoke stop $MOVIES_SERVICE \u003e/dev/null || true fi Agora é só incluir todos os arquivos no pacote Debian atualizado o .goreleaser.yaml\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -46,7 +46,14 @@ nfpms: license: MIT formats: - deb + contents: + - src: \"env/debian/movies.service\" + dst: \"/lib/systemd/system/movies.service\" + - src: \"env/debian/movies.conf\" + dst: \"/etc/default/movies\" + type: config scripts: + preremove: \"env/debian/pre-remove.sh\" postinstall: \"env/debian/post-install.sh\" postremove: \"env/debian/post-remove.sh\" Quando o pacote for instalado no sistema operacional, automaticamente será copiado os arquivos da seção contents para os respectivos destinos, fará o registro no systemd e iniciará automaticamente.\nPoderia dizer que o empacotamento e a distribuição do aplicativo está finalizado, mas ainda temos um último problema para ser resolvido, vejamos na última parte.\n5. Atualização e tempo de inatividade Instalar ou atualizar ficou extremamente simples e com um controle mais rígido, todavia, a aplicação pode ficar inativa durante a atualização. Isso ocorre pelo simples fato de finalizar o serviço e instalar uma nova versão, e tendo uma degradação da disponibilidade.\nFelizmente, isso pode ser contornado ainda usando o systemd, através de um outro unit, o socket. Esse arquivo de unit codifica a informação sobre um soquete de rede ou arquivo, controlado e supervisionado, para uma ativação baseada em sockets.\nVale lembrar que os unit sockets não iniciam os serviços por conta própria, em vez disso, eles apenas esperam e escutam um endereço IP:PORT, ou um Unix socket, e quando algo se conecta a ele, o serviço ao qual o socket se destina será iniciado e a conexão é entregue a ele. Já que nossa aplicação lida com requisições HTTP, podemos usá-lo.\nAlguns passos adicionais precisarão ser concluídos, como a criação e modificação dos units, alteração dos hooks, e uma mudança na aplicação, pois ela precisa suportar essa funcionalidade.\nmovies.socket:\n[Unit] Description=Manages movie collection through API Documentation=\"https://github.com/faabiosr/go-movies-demo\" [Socket] ListenStream=8000 SocketUser=movies-demo SocketGroup=movies-demo [Install] WantedBy=sockets.target Aliás, é necessário atualizar o movies.service e informar que o unit socket é requerido:\ndiff --git a/env/debian/movies.service b/env/debian/movies.service --- a/env/debian/movies.service +++ b/env/debian/movies.service @@ -1,6 +1,8 @@ [Unit] Description=Manages movie collection through API Documentation=\"https://github.com/faabiosr/go-movies-demo\" +After=network.target +Requires=movies.socket [Service] EnvironmentFile=/etc/default/movies Alteramos também os hooks do Debian:\npostinst (post-install.sh): também fará o registro do unit socket e só reiniciará o serviço caso houver uma atualização no pacote.\ndiff --git a/env/debian/post-install.sh b/env/debian/post-install.sh --- a/env/debian/post-install.sh +++ b/env/debian/post-install.sh @@ -5,6 +5,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo MOVIES_SERVICE=movies.service +MOVIES_SOCKET=movies.socket if [ \"$1\" = \"configure\" ]; then # creating user and group @@ -30,16 +31,24 @@ if [ \"$1\" = \"configure\" ]; then deb-systemd-helper update-state $MOVIES_SERVICE \u003e/dev/null || true fi + # enable systemd socket + deb-systemd-helper unmask $MOVIES_SOCKET \u003e/dev/null || true + + if deb-systemd-helper --quiet was-enabled $MOVIES_SOCKET; then + deb-systemd-helper enable $MOVIES_SOCKET \u003e/dev/null || true + else + deb-systemd-helper update-state $MOVIES_SOCKET \u003e/dev/null || true + fi + # starting service if [ -d /run/systemd/system ]; then systemctl --system daemon-reload \u003e/dev/null || true if [ -n \"$2\" ]; then - _dh_action=restart + deb-systemd-invoke restart $MOVIES_SERVICE \u003e/dev/null || true else - _dh_action=start + deb-systemd-invoke start $MOVIES_SOCKET \u003e/dev/null || true fi - deb-systemd-invoke $_dh_action $MOVIES_SERVICE \u003e/dev/null || true fi fi prerm (pre-remove.sh): quando seja feita uma atualização, apenas o serviço será desligado, finalizará o socket, e o serviço apenas na remoção.\ndiff --git a/env/debian/pre-remove.sh b/env/debian/pre-remove.sh --- a/env/debian/pre-remove.sh +++ b/env/debian/pre-remove.sh @@ -3,8 +3,18 @@ set -e MOVIES_SERVICE=movies.service +MOVIES_SOCKET=movies.socket -# stopping service -if [ -d /run/systemd/system ]; then - deb-systemd-invoke stop $MOVIES_SERVICE \u003e/dev/null || true +if [ \"$1\" = \"remove\" ]; then + # stopping service and socket + if [ -d /run/systemd/system ]; then + deb-systemd-invoke stop $MOVIES_SERVICE $MOVIES_SOCKET \u003e/dev/null || true + fi +fi + +if [ \"$1\" = \"upgrade\" ]; then + # stopping service + if [ -d /run/systemd/system ]; then + deb-systemd-invoke stop $MOVIES_SERVICE \u003e/dev/null || true + fi fi No arquivo .goreleaser.yaml, foi incluído o arquivo .socket, na seção contents:\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -49,6 +49,8 @@ nfpms: contents: - src: \"env/debian/movies.service\" dst: \"/lib/systemd/system/movies.service\" + - src: \"env/debian/movies.socket\" + dst: \"/lib/systemd/system/movies.socket\" - src: \"env/debian/movies.conf\" dst: \"/etc/default/movies\" type: config Independente de configurar o systemd, a aplicação ainda não está preparada para fazer uso de sockets, para isso vamos adicionar o suporte de ativação de sockets.\nA equipe do CoreOS desenvolveu o pacote go-systemd, nele contém várias ferramentas para integrar com o systemd, entre eles o activation.\nmain.go: inclusão do activation e integração com o servidor http.\ndiff --git a/cmd/movies/main.go b/cmd/movies/main.go --- a/cmd/movies/main.go +++ b/cmd/movies/main.go @@ -7,6 +7,7 @@ import ( \"path/filepath\" \"time\" +\t\"github.com/coreos/go-systemd/activation\" \"github.com/labstack/echo/v4\" bolt \"go.etcd.io/bbolt\" @@ -46,7 +47,7 @@ func main() { e.Logger.Infof(\"%s service\", appName) go func() { -\tif err := e.Start(appAddr); err != nil { +\tif err := start(e, appAddr); err != nil { e.Logger.Info(\"shutting down the service\") } }() @@ -64,3 +65,16 @@ func main() { e.Logger.Fatal(err) } } + +func start(e *echo.Echo, host string) error { +\tlisteners, err := activation.Listeners() +\tif err != nil { +\treturn nil +\t} + +\tif len(listeners) \u003e 0 { +\te.Listener = listeners[0] +\t} + +\treturn e.Start(host) +} Com essa parte final, a aplicação terá garantias de disponibilidade durante uma reinicialização ou atualização, e estará completamente funcional para distribuir.\nConclusão Agora nós sabemos como empacotar e distribuir o aplicativo, seguindo um modelo onde podemos versionar, preparar as dependências, e garantir disponibilidade.\nAcredito que os pontos compartilhados, não tem um curva de dificuldade alta, mas sim, pontos estratégicos para futura manutenção do aplicativo, tal qual, reduzir a complexidade na hora de distribuir a aplicação, e o ponto central é tirar proveito das ferramentas que estão disponíveis no sistema operacional que será rodado.\nA aplicação completa usada no artigo está em https://github.com/faabiosr/go-movies-demo, você encontrará tudo lá.\nComo prometido, aqui vai um link de créditos para brincar na Digital Ocean e criar os seus droplets.\nRecomendo a leitura das referências abaixo para entender um pouco mais sobre o systemd, e os hooks do Debian:\nUnderstanding Systemd Units and Unit Files Systemd system and service manager deb-prerm, deb-postinst, deb-postrm ","wordCount":"2600","inLanguage":"en","datePublished":"2023-10-27T20:00:00+02:00","dateModified":"2023-10-27T20:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/"},"publisher":{"@type":"Organization","name":"Fabio Ribeiro","logo":{"@type":"ImageObject","url":"https://fabioribeiro.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fabioribeiro.dev/ accesskey=h title="Fabio Ribeiro (Alt + H)">Fabio Ribeiro</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://fabioribeiro.dev/archive/ title=Blog><span>Blog</span></a></li><li><a href=https://fabioribeiro.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Distribuindo um aplicação Go sem o Docker</h1><div class=post-meta><span title='2023-10-27 20:00:00 +0200 +0200'>October 27, 2023</span></div></header><div class=post-content><p>Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.</p><p>A grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho <code>docker-compose.yaml</code>.</p><p>Dependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina.</p><p>Nesse artigo, apresento um compilado de como distribuir a sua aplicação para ser executada diretamente no servidor, por exemplo na sua instância AWS EC2, Google Compute Engine, e quem sabe talvez no seu droplet na Digital Ocean (no final do artigo compartilho um cupom de crédito para você brincar).</p><p>Tudo será apresentado em passos que serão incrementais, o empacotamento de uma aplicação em Golang, a preparação das dependências requeridas, a execução, e finalizamos com a atualização e tempo de inatividade.</p><p>De forma simplificada, uma aplicação será desenvolvida, e para cada mudança, novas <code>tags</code> serão criadas, e iremos focar o empacotamento e distribuição usando Ubuntu Linux (server). Ao final deixo o link onde você encontrará o projeto completo.</p><h2 id=a-aplicação>A aplicação<a hidden class=anchor aria-hidden=true href=#a-aplicação>#</a></h2><p>Antes de tudo, precisaremos de uma aplicação,e ela guardará os nomes dos filmes e seu dia de lançamento. Na parte que cabe ao banco de dados, eles serão armazenados em um banco de dados em arquivo, e é requerido que seja definida uma variável de ambiente chamada <code>MOVIES_DB_PATH</code>, onde contém a localização deste arquivo.</p><p>Vamos para a aplicação em si (<em>de momento não se preocupe com as libs usadas, tudo estará no repositório no final do artigo</em>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;context&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os/signal&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;path/filepath&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/labstack/echo/v4&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bolt</span> <span style=color:#e6db74>&#34;go.etcd.io/bbolt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/faabiosr/go-movies-demo/internal/movies&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>appAddr</span>   = <span style=color:#e6db74>&#34;0.0.0.0:8000&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>appName</span>   = <span style=color:#e6db74>&#34;moviez&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dbName</span>    = <span style=color:#e6db74>&#34;catalog.db&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dbPathEnv</span> = <span style=color:#e6db74>&#34;MOVIES_DB_PATH&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>timeout</span> = <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>echo</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#a6e22e>dbPathEnv</span>) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;env &#39;%s&#39; was not defined&#34;</span>, <span style=color:#a6e22e>dbPathEnv</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dbPath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#a6e22e>dbPathEnv</span>), <span style=color:#a6e22e>dbName</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Database connect</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>dbPath</span>, <span style=color:#ae81ff>0</span><span style=color:#a6e22e>o600</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ds</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>movies</span>.<span style=color:#a6e22e>NewDatasource</span>(<span style=color:#a6e22e>db</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// API Resources</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>movies</span>.<span style=color:#a6e22e>Routes</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Group</span>(<span style=color:#e6db74>&#34;/movies&#34;</span>), <span style=color:#a6e22e>ds</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Start server</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;%s service&#34;</span>, <span style=color:#a6e22e>appName</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>appAddr</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;shutting down the service&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Graceful shutdown</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>quit</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Signal</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>signal</span>.<span style=color:#a6e22e>Notify</span>(<span style=color:#a6e22e>quit</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Interrupt</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>quit</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>TODO</span>(), <span style=color:#a6e22e>timeout</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Shutdown</span>(<span style=color:#a6e22e>ctx</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note o ponto que informamos anteriormente, a aplicação necessita da variável de ambiente <code>MOVIES_DB_PATH</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dbName</span>    = <span style=color:#e6db74>&#34;catalog.db&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dbPathEnv</span> = <span style=color:#e6db74>&#34;MOVIES_DB_PATH&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dbPath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#a6e22e>dbPathEnv</span>), <span style=color:#a6e22e>dbName</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Database connect</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>dbPath</span>, <span style=color:#ae81ff>0</span><span style=color:#a6e22e>o600</span>, <span style=color:#66d9ef>nil</span>)
</span></span></code></pre></div><p>Agora que temos a aplicação de exemplo, é hora de compilar, e é bem simples, o resultado do comando abaixo será um binário com o nome de <code>movies</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go build -o movies ./cmd/movies
</span></span></code></pre></div><p>Com o binário em mãos, já podemos copiar e executar no servidor.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>MOVIES_DB_PATH<span style=color:#f92672>=</span>/tmp ./movies
</span></span></code></pre></div><p>Pronto é isso! Guia finalizado!</p><p><em>WTF?</em></p><p><em>OK, calma, calma!</em></p><p>Mesmo com o binário criado, a distribuição não é fácil, copiar para o servidor todas as vezes que houver uma nova atualização e executar manualmente pode tornar-se complexo e chato.</p><p>Vale ressaltar que não há uma forma consistente para a instalação, e não há como evitar que seja usada outra pasta no servidor, tornando o processo difícil de controlar e passível a erros.</p><h2 id=2-empacotando-o-binário>2. Empacotando o binário<a hidden class=anchor aria-hidden=true href=#2-empacotando-o-binário>#</a></h2><p>Sabendo que a aplicação será executada em um Ubuntu Linux, temos a possibilidade de distribuir como um pacote <code>Debian (deb)</code>, ou até mesmo como <code>snap</code>, mas neste exemplo iremos focar no Debian.</p><p>Empacotar como <code>.deb</code> nos dá algumas vantagens, como:</p><ul><li>Poder controlar a versão do pacote.</li><li>Executar scripts antes e depois da instalação/remoção do pacote.</li><li>Adicionar arquivos extras.</li></ul><p>Preparar um pacote Debian &ldquo;na mão&rdquo;, não é uma tarefa muito simples, e para facilitar a nossa vida vamos usar o <a href=https://github.com/goreleaser/goreleaser>GoReleaser</a>, essa ferramenta maravilhosa, que internamente faz uso da é <a href=https://github.com/goreleaser/nfpm>nFPM</a>, responsável por criar pacotes Linux. Também é importante dizer que o GoReleaser não só nos ajuda a criar os pacotes Debian, mas também pacotes para Windows, MacOS, RPM, APK e muito mais.</p><p>Em nosso projeto, vamos definir o arquivo <a href=https://github.com/faabiosr/go-movies-demo/blob/v0.0.2/.goreleaser.yaml>.goreleaser.yaml</a>, que contém as informações do pacote a ser gerado, atente-se para seção compartilhada abaixo e note que em <code>formats</code> foi definido o <code>.deb</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>nfpms</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>movies</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>package_name</span>: <span style=color:#ae81ff>movies</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file_name_template</span>: <span style=color:#e6db74>&#34;{{ .ConventionalFileName }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>description</span>: <span style=color:#ae81ff>Manages movie collection through API</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>license</span>: <span style=color:#ae81ff>MIT</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>formats</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>deb</span>
</span></span></code></pre></div><p>Adicionalmente, foi configurado o <a href=https://github.com/faabiosr/go-movies-demo/blob/main/.github/workflows/release.yml>Github Workflows</a> onde contém os passos para compilar e distribuir em <code>.deb</code>, e o resultado é esse:</p><p><img alt="contém um printscreen da lista de arquivos gerados pelo Goreleaser" loading=lazy src=/images/releases.png></p><p><em>Todas as versões criadas estarão em <a href=https://github.com/faabiosr/go-movies-demo/releases>releases</a>.</em></p><p>Pronto! Agora sim temos um maior controle sobre o versionamento e distribuição da aplicação. De maneira simples e consistente podemos instalar em qualquer distro baseada em Debian.</p><h2 id=3-lidando-com-dependências-banco-de-dados-em-arquivo>3. Lidando com dependências (banco de dados em arquivo)<a hidden class=anchor aria-hidden=true href=#3-lidando-com-dependências-banco-de-dados-em-arquivo>#</a></h2><p>Anteriormente foi mencionado que a aplicação necessita de uma pasta onde o banco de dados será criado, a pasta elegida será em <code>/var/lib/movies-demo</code>, e para a criá-la vamos usar alguns dos hooks que pacote Debian nos fornece:</p><p><code>postinst (post-install.sh)</code>: é executado após instalar ou atualizar um pacote, esse hook ficará responsável por criar a pasta definida acima e também o usuário/grupo dessa pasta (<em>é recomendável que sempre tenha um usuário/grupo, ficando isolado dos demais</em>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MOVIES_DB_PATH<span style=color:#f92672>=</span>/var/lib/movies-demo
</span></span><span style=display:flex><span>MOVIES_USER<span style=color:#f92672>=</span>movies-demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;configure&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># creating user and group</span>
</span></span><span style=display:flex><span>    adduser --quiet <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>            --system <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>            --home /nonexistent <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>            --no-create-home <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>            --disabled-password <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>            --group <span style=color:#e6db74>&#34;</span>$MOVIES_USER<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># creating database folder</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d $MOVIES_DB_PATH <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        mkdir -p $MOVIES_DB_PATH
</span></span><span style=display:flex><span>        chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>Da mesma maneira que temos o <code>postinst</code>, também temos um hook para quando removemos o pacote.</p><p><code>postrm (post-remove-sh)</code>: é executado quando removemos um pacote, e removerá a pasta apenas quando o arquivo de <code>catalog.db</code> não existir.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MOVIES_DB_PATH<span style=color:#f92672>=</span>/var/lib/movies-demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;remove&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f <span style=color:#e6db74>&#34;</span>$MOVIES_DB_PATH<span style=color:#e6db74>/catalog.db&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;Database file found and won&#39;t be removed.&#34;</span> &gt;&amp;<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;Removing database folder.&#34;</span> &gt;&amp;<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        rm -fr $MOVIES_DB_PATH
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>Scripts prontos, agora é só fazer a inclusão deles no <code>.goreleaser.yaml</code> e quando empacotar e instalar a aplicação novamente, a pasta será criada:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/.goreleaser.yaml b/.goreleaser.yaml
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/.goreleaser.yaml
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/.goreleaser.yaml
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -46,6 +46,9 @@ nfpms:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     license: MIT
</span></span><span style=display:flex><span>     formats:
</span></span><span style=display:flex><span>       - deb
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    scripts:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+      postinstall: &#34;env/debian/post-install.sh&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+      postremove: &#34;env/debian/post-remove.sh&#34;
</span></span></span></code></pre></div><h2 id=4-rodando-a-aplicação-em-background-como-um-serviço-systemd>4. Rodando a aplicação em background como um serviço (systemd)<a hidden class=anchor aria-hidden=true href=#4-rodando-a-aplicação-em-background-como-um-serviço-systemd>#</a></h2><p>A pasta já está pronta, mas a execução pela linha de comando continua sendo manual, e para resolver essa questão, vamos executar a aplicação em background como um serviço. Para isso tiraremos proveito do <a href=https://systemd.io/>systemd</a>, que já vem instalado no Ubuntu Linux.</p><p>Em poucas palavras, o <code>systemd</code> é um conjunto de blocos de construção para uma sistema Linux, ele fornece um gerenciador de sistema e serviço, e é justamente do segundo ponto que necessitamos.</p><p>Para um serviço é requerido que seja criado um arquivo onde contém as referências para um recurso que o sistema saberá como operar e gerenciar, chamado de <code>unit</code>.</p><p>O unit que usaremos é o <code>service</code>, que descreve como gerenciar um serviço ou aplicação no servidor:</p><p><code>movies.service</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Manages movie collection through API</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Documentation</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://github.com/faabiosr/go-movies-demo&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>EnvironmentFile</span><span style=color:#f92672>=</span><span style=color:#e6db74>/etc/default/movies</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/bin/movies</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>on-failure</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>User</span><span style=color:#f92672>=</span><span style=color:#e6db74>movies-demo</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Group</span><span style=color:#f92672>=</span><span style=color:#e6db74>movies-demo</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>KillSignal</span><span style=color:#f92672>=</span><span style=color:#e6db74>SIGINT</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><p>Na seção <code>Service</code>:</p><ul><li>EnvironmentFile: arquivo que contém as variáveis de ambiente.</li><li>ExecStart: caminho do binário.</li><li>User/Group: usaremos o mesmo criado anteriormente.</li></ul><p>Precisaremos agora criar um arquivo que contém a variável de ambiente usada pela aplicação:</p><p><code>movies.conf</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-env data-lang=env><span style=display:flex><span>MOVIES_DB_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/var/lib/movies-demo&#34;</span>
</span></span></code></pre></div><p>Uma vez finalizada a criação dos arquivos necessários para o systemd, é imprescindível atualizar os hooks do debian para que o mesmo seja ativado e incializado após a instalação:</p><p><code>postint (post-install.sh)</code>: ativa o serviço se não foi ativo, e inicia ou reinicia caso já esteja rodando.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/env/debian/post-install.sh b/env/debian/post-install.sh
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/env/debian/post-install.sh
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/env/debian/post-install.sh
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -4,6 +4,7 @@ set -e
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span> MOVIES_DB_PATH=/var/lib/movies-demo
</span></span><span style=display:flex><span> MOVIES_USER=movies-demo
</span></span><span style=display:flex><span><span style=color:#a6e22e>+MOVIES_SERVICE=movies.service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span> if [ &#34;$1&#34; = &#34;configure&#34; ]; then
</span></span><span style=display:flex><span>     # creating user and group
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -20,5 +21,25 @@ if [ &#34;$1&#34; = &#34;configure&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH
</span></span><span style=display:flex><span>     fi
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-    exit 0
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    # enable systemd service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    deb-systemd-helper unmask $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if deb-systemd-helper --quiet was-enabled $MOVIES_SERVICE; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-helper enable $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    else
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-helper update-state $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    # starting service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if [ -d /run/systemd/system ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        systemctl --system daemon-reload &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        if [ -n &#34;$2&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            _dh_action=restart
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        else
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            _dh_action=start
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-invoke $_dh_action $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> fi
</span></span></code></pre></div><p><code>postrm (post-remove.sh)</code>: a nova adição irá reiniciar o serviço do próprio systemd, e o serviço só será removido caso o usuário opte por uma remoção completa.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/env/debian/post-remove.sh b/env/debian/post-remove.sh
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/env/debian/post-remove.sh
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/env/debian/post-remove.sh
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -3,6 +3,7 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> set -e
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> MOVIES_DB_PATH=/var/lib/movies-demo
</span></span><span style=display:flex><span><span style=color:#a6e22e>+MOVIES_SERVICE=movies.service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span> if [ &#34;$1&#34; = &#34;remove&#34; ]; then
</span></span><span style=display:flex><span>     if [ -f &#34;$MOVIES_DB_PATH/catalog.db&#34; ]; then
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -12,5 +13,16 @@ if [ &#34;$1&#34; = &#34;remove&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         rm -fr $MOVIES_DB_PATH
</span></span><span style=display:flex><span>     fi
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-    exit 0
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    # disabling service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if [ -d /run/systemd/system ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        systemctl --system daemon-reload &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    deb-systemd-helper mask $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+if [ &#34;$1&#34; = &#34;purge&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    # disabling service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    deb-systemd-helper purge $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    deb-systemd-helper unmask $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> fi
</span></span></code></pre></div><p>Adicionalmente criamos o <code>prerm</code> hook, que é executado antes de remover o pacote, e será ele responsável por finalizar a execução da aplicação, assim removemos o pacote de forma segura:</p><p><code>prerm (pre-remove.sh)</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MOVIES_SERVICE<span style=color:#f92672>=</span>movies.service
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># stopping service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -d /run/systemd/system <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    deb-systemd-invoke stop $MOVIES_SERVICE &gt;/dev/null <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>Agora é só incluir todos os arquivos no pacote Debian atualizado o <code>.goreleaser.yaml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/.goreleaser.yaml b/.goreleaser.yaml
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/.goreleaser.yaml
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/.goreleaser.yaml
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -46,7 +46,14 @@ nfpms:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     license: MIT
</span></span><span style=display:flex><span>     formats:
</span></span><span style=display:flex><span>       - deb
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    contents:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+      - src: &#34;env/debian/movies.service&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        dst: &#34;/lib/systemd/system/movies.service&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+      - src: &#34;env/debian/movies.conf&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        dst: &#34;/etc/default/movies&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        type: config
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     scripts:
</span></span><span style=display:flex><span><span style=color:#a6e22e>+      preremove: &#34;env/debian/pre-remove.sh&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>       postinstall: &#34;env/debian/post-install.sh&#34;
</span></span><span style=display:flex><span>       postremove: &#34;env/debian/post-remove.sh&#34;
</span></span></code></pre></div><p>Quando o pacote for instalado no sistema operacional, automaticamente será copiado os arquivos da seção <code>contents</code> para os respectivos destinos, fará o registro no systemd e iniciará automaticamente.</p><p>Poderia dizer que o empacotamento e a distribuição do aplicativo está finalizado, mas ainda temos um último problema para ser resolvido, vejamos na última parte.</p><h2 id=5-atualização-e-tempo-de-inatividade>5. Atualização e tempo de inatividade<a hidden class=anchor aria-hidden=true href=#5-atualização-e-tempo-de-inatividade>#</a></h2><p>Instalar ou atualizar ficou extremamente simples e com um controle mais rígido, todavia, a aplicação pode ficar inativa durante a atualização. Isso ocorre pelo simples fato de finalizar o serviço e instalar uma nova versão, e tendo uma degradação da disponibilidade.</p><p>Felizmente, isso pode ser contornado ainda usando o systemd, através de um outro unit, o <code>socket</code>. Esse arquivo de unit codifica a informação sobre um soquete de rede ou arquivo, controlado e supervisionado, para uma ativação baseada em sockets.</p><p>Vale lembrar que os unit <code>sockets</code> não iniciam os serviços por conta própria, em vez disso, eles apenas esperam e escutam um endereço <code>IP:PORT</code>, ou um <code>Unix</code> socket, e quando algo se conecta a ele, o serviço ao qual o socket se destina será iniciado e a conexão é entregue a ele. Já que nossa aplicação lida com requisições HTTP, podemos usá-lo.</p><p>Alguns passos adicionais precisarão ser concluídos, como a criação e modificação dos units, alteração dos hooks, e uma mudança na aplicação, pois ela precisa suportar essa funcionalidade.</p><p><code>movies.socket</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Manages movie collection through API</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Documentation</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;https://github.com/faabiosr/go-movies-demo&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Socket]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ListenStream</span><span style=color:#f92672>=</span><span style=color:#e6db74>8000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SocketUser</span><span style=color:#f92672>=</span><span style=color:#e6db74>movies-demo</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SocketGroup</span><span style=color:#f92672>=</span><span style=color:#e6db74>movies-demo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>sockets.target</span>
</span></span></code></pre></div><p>Aliás, é necessário atualizar o <code>movies.service</code> e informar que o unit socket é requerido:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/env/debian/movies.service b/env/debian/movies.service
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/env/debian/movies.service
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/env/debian/movies.service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -1,6 +1,8 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> [Unit]
</span></span><span style=display:flex><span> Description=Manages movie collection through API
</span></span><span style=display:flex><span> Documentation=&#34;https://github.com/faabiosr/go-movies-demo&#34;
</span></span><span style=display:flex><span><span style=color:#a6e22e>+After=network.target
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+Requires=movies.socket
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span> [Service]
</span></span><span style=display:flex><span> EnvironmentFile=/etc/default/movies
</span></span></code></pre></div><p>Alteramos também os hooks do Debian:</p><p><code>postinst (post-install.sh)</code>: também fará o registro do unit socket e só reiniciará o serviço caso houver uma atualização no pacote.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/env/debian/post-install.sh b/env/debian/post-install.sh
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/env/debian/post-install.sh
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/env/debian/post-install.sh
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -5,6 +5,7 @@ set -e
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> MOVIES_DB_PATH=/var/lib/movies-demo
</span></span><span style=display:flex><span> MOVIES_USER=movies-demo
</span></span><span style=display:flex><span> MOVIES_SERVICE=movies.service
</span></span><span style=display:flex><span><span style=color:#a6e22e>+MOVIES_SOCKET=movies.socket
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span> if [ &#34;$1&#34; = &#34;configure&#34; ]; then
</span></span><span style=display:flex><span>     # creating user and group
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -30,16 +31,24 @@ if [ &#34;$1&#34; = &#34;configure&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         deb-systemd-helper update-state $MOVIES_SERVICE &gt;/dev/null || true
</span></span><span style=display:flex><span>     fi
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    # enable systemd socket
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    deb-systemd-helper unmask $MOVIES_SOCKET &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if deb-systemd-helper --quiet was-enabled $MOVIES_SOCKET; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-helper enable $MOVIES_SOCKET &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    else
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-helper update-state $MOVIES_SOCKET &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     # starting service
</span></span><span style=display:flex><span>     if [ -d /run/systemd/system ]; then
</span></span><span style=display:flex><span>         systemctl --system daemon-reload &gt;/dev/null || true
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>         if [ -n &#34;$2&#34; ]; then
</span></span><span style=display:flex><span><span style=color:#f92672>-            _dh_action=restart
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+            deb-systemd-invoke restart $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         else
</span></span><span style=display:flex><span><span style=color:#f92672>-            _dh_action=start
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+            deb-systemd-invoke start $MOVIES_SOCKET &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         fi
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-        deb-systemd-invoke $_dh_action $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>     fi
</span></span><span style=display:flex><span> fi
</span></span></code></pre></div><p><code>prerm (pre-remove.sh)</code>: quando seja feita uma atualização, apenas o serviço será desligado, finalizará o socket, e o serviço apenas na remoção.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/env/debian/pre-remove.sh b/env/debian/pre-remove.sh
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/env/debian/pre-remove.sh
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/env/debian/pre-remove.sh
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -3,8 +3,18 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> set -e
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> MOVIES_SERVICE=movies.service
</span></span><span style=display:flex><span><span style=color:#a6e22e>+MOVIES_SOCKET=movies.socket
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-# stopping service
</span></span></span><span style=display:flex><span><span style=color:#f92672>-if [ -d /run/systemd/system ]; then
</span></span></span><span style=display:flex><span><span style=color:#f92672>-    deb-systemd-invoke stop $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+if [ &#34;$1&#34; = &#34;remove&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    # stopping service and socket
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if [ -d /run/systemd/system ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-invoke stop $MOVIES_SERVICE $MOVIES_SOCKET &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+if [ &#34;$1&#34; = &#34;upgrade&#34; ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    # stopping service
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if [ -d /run/systemd/system ]; then
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        deb-systemd-invoke stop $MOVIES_SERVICE &gt;/dev/null || true
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    fi
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> fi
</span></span></code></pre></div><p>No arquivo <code>.goreleaser.yaml</code>, foi incluído o arquivo <code>.socket</code>, na seção contents:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/.goreleaser.yaml b/.goreleaser.yaml
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/.goreleaser.yaml
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/.goreleaser.yaml
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -49,6 +49,8 @@ nfpms:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     contents:
</span></span><span style=display:flex><span>       - src: &#34;env/debian/movies.service&#34;
</span></span><span style=display:flex><span>         dst: &#34;/lib/systemd/system/movies.service&#34;
</span></span><span style=display:flex><span><span style=color:#a6e22e>+      - src: &#34;env/debian/movies.socket&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        dst: &#34;/lib/systemd/system/movies.socket&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>       - src: &#34;env/debian/movies.conf&#34;
</span></span><span style=display:flex><span>         dst: &#34;/etc/default/movies&#34;
</span></span><span style=display:flex><span>         type: config
</span></span></code></pre></div><p>Independente de configurar o systemd, a aplicação ainda não está preparada para fazer uso de sockets, para isso vamos adicionar o suporte de ativação de sockets.</p><p>A equipe do <a href=https://github.com/coreos>CoreOS</a> desenvolveu o pacote <a href=https://github.com/coreos/go-systemd>go-systemd</a>, nele contém várias ferramentas para integrar com o systemd, entre eles o <code>activation</code>.</p><p><code>main.go</code>: inclusão do <code>activation</code> e integração com o servidor http.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/cmd/movies/main.go b/cmd/movies/main.go
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/cmd/movies/main.go
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/cmd/movies/main.go
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -7,6 +7,7 @@ import (
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	&#34;path/filepath&#34;
</span></span><span style=display:flex><span> 	&#34;time&#34;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>+	&#34;github.com/coreos/go-systemd/activation&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 	&#34;github.com/labstack/echo/v4&#34;
</span></span><span style=display:flex><span> 	bolt &#34;go.etcd.io/bbolt&#34;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -46,7 +47,7 @@ func main() {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	e.Logger.Infof(&#34;%s service&#34;, appName)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> 	go func() {
</span></span><span style=display:flex><span><span style=color:#f92672>-		if err := e.Start(appAddr); err != nil {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+		if err := start(e, appAddr); err != nil {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> 			e.Logger.Info(&#34;shutting down the service&#34;)
</span></span><span style=display:flex><span> 		}
</span></span><span style=display:flex><span> 	}()
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -64,3 +65,16 @@ func main() {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 		e.Logger.Fatal(err)
</span></span><span style=display:flex><span> 	}
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+func start(e *echo.Echo, host string) error {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	listeners, err := activation.Listeners()
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if err != nil {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		return nil
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	if len(listeners) &gt; 0 {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		e.Listener = listeners[0]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	return e.Start(host)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+}
</span></span></span></code></pre></div><p>Com essa parte final, a aplicação terá garantias de disponibilidade durante uma reinicialização ou atualização, e estará completamente funcional para distribuir.</p><h2 id=conclusão>Conclusão<a hidden class=anchor aria-hidden=true href=#conclusão>#</a></h2><p>Agora nós sabemos como empacotar e distribuir o aplicativo, seguindo um modelo onde podemos versionar, preparar as dependências, e garantir disponibilidade.</p><p>Acredito que os pontos compartilhados, não tem um curva de dificuldade alta, mas sim, pontos estratégicos para futura manutenção do aplicativo, tal qual, reduzir a complexidade na hora de distribuir a aplicação, e o ponto central é tirar proveito das ferramentas que estão disponíveis no sistema operacional que será rodado.</p><p>A aplicação completa usada no artigo está em <a href=https://github.com/faabiosr/go-movies-demo>https://github.com/faabiosr/go-movies-demo</a>, você encontrará tudo lá.</p><p>Como prometido, aqui vai um link de créditos para brincar na <a href=https://m.do.co/c/67aea006f19f>Digital Ocean</a> e criar os seus droplets.</p><p>Recomendo a leitura das referências abaixo para entender um pouco mais sobre o systemd, e os hooks do Debian:</p><ul><li><a href=https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files>Understanding Systemd Units and Unit Files</a></li><li><a href=https://www.freedesktop.org/software/systemd/man/latest/systemd.html#>Systemd system and service manager</a></li><li><a href=https://manpages.debian.org/bullseye/dpkg-dev/deb-prerm.5.en.html>deb-prerm</a>, <a href=https://manpages.debian.org/bullseye/dpkg-dev/deb-postinst.5.en.html>deb-postinst</a>, <a href=https://manpages.debian.org/bullseye/dpkg-dev/deb-postrm.5.en.html>deb-postrm</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fabioribeiro.dev/tags/go/>Go</a></li><li><a href=https://fabioribeiro.dev/tags/docker/>Docker</a></li><li><a href=https://fabioribeiro.dev/tags/programming/>Programming</a></li><li><a href=https://fabioribeiro.dev/tags/linux/>Linux</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>