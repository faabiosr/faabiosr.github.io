[{"content":"Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.\nA grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribui√ß√£o de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e √†s vezes preparando o bom e velho docker-compose.yaml.\nDependendo do tamanho da sua aplica√ß√£o, √†s vezes n√£o √© necess√°rio ter um cluster de Kubernetes, tamb√©m em alguns casos queremos obter todo o potencial do servidor, como mem√≥ria, disco e rede, evitando ter uma camada extra entre a aplica√ß√£o e a m√°quina.\nNesse artigo, apresento um compilado de como distribuir a sua aplica√ß√£o para ser executada diretamente no servidor, por exemplo na sua inst√¢ncia AWS EC2, Google Compute Engine, e quem sabe talvez no seu droplet na Digital Ocean (no final do artigo compartilho um cupom de cr√©dito para voc√™ brincar).\nTudo ser√° apresentado em passos que ser√£o incrementais, o empacotamento de uma aplica√ß√£o em Golang, a prepara√ß√£o das depend√™ncias requeridas, a execu√ß√£o, e finalizamos com a atualiza√ß√£o e tempo de inatividade.\nDe forma simplificada, uma aplica√ß√£o ser√° desenvolvida, e para cada mudan√ßa, novas tags ser√£o criadas, e iremos focar o empacotamento e distribui√ß√£o usando Ubuntu Linux (server). Ao final deixo o link onde voc√™ encontrar√° o projeto completo.\nA aplica√ß√£o Antes de tudo, precisaremos de uma aplica√ß√£o,e ela guardar√° os nomes dos filmes e seu dia de lan√ßamento. Na parte que cabe ao banco de dados, eles ser√£o armazenados em um banco de dados em arquivo, e √© requerido que seja definida uma vari√°vel de ambiente chamada MOVIES_DB_PATH, onde cont√©m a localiza√ß√£o deste arquivo.\nVamos para a aplica√ß√£o em si (de momento n√£o se preocupe com as libs usadas, tudo estar√° no reposit√≥rio no final do artigo):\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; bolt \u0026#34;go.etcd.io/bbolt\u0026#34; \u0026#34;github.com/faabiosr/go-movies-demo/internal/movies\u0026#34; ) const ( appAddr = \u0026#34;0.0.0.0:8000\u0026#34; appName = \u0026#34;moviez\u0026#34; dbName = \u0026#34;catalog.db\u0026#34; dbPathEnv = \u0026#34;MOVIES_DB_PATH\u0026#34; ) const timeout = 10 * time.Second func main() { e := echo.New() if os.Getenv(dbPathEnv) == \u0026#34;\u0026#34; { e.Logger.Fatalf(\u0026#34;env \u0026#39;%s\u0026#39; was not defined\u0026#34;, dbPathEnv) } dbPath := filepath.Join(os.Getenv(dbPathEnv), dbName) // Database connect db, err := bolt.Open(dbPath, 0o600, nil) if err != nil { e.Logger.Fatal(err) } ds := movies.NewDatasource(db) // API Resources movies.Routes(e.Group(\u0026#34;/movies\u0026#34;), ds) // Start server e.Logger.Infof(\u0026#34;%s service\u0026#34;, appName) go func() { if err := e.Start(appAddr); err != nil { e.Logger.Info(\u0026#34;shutting down the service\u0026#34;) } }() // Graceful shutdown quit := make(chan os.Signal, 1) signal.Notify(quit, os.Interrupt) \u0026lt;-quit ctx, cancel := context.WithTimeout(context.TODO(), timeout) defer cancel() if err := e.Shutdown(ctx); err != nil { e.Logger.Fatal(err) } } Note o ponto que informamos anteriormente, a aplica√ß√£o necessita da vari√°vel de ambiente MOVIES_DB_PATH:\npackage main const ( dbName = \u0026#34;catalog.db\u0026#34; dbPathEnv = \u0026#34;MOVIES_DB_PATH\u0026#34; ) func main() { dbPath := filepath.Join(os.Getenv(dbPathEnv), dbName) // Database connect db, err := bolt.Open(dbPath, 0o600, nil) Agora que temos a aplica√ß√£o de exemplo, √© hora de compilar, e √© bem simples, o resultado do comando abaixo ser√° um bin√°rio com o nome de movies:\ngo build -o movies ./cmd/movies Com o bin√°rio em m√£os, j√° podemos copiar e executar no servidor.\nMOVIES_DB_PATH=/tmp ./movies Pronto √© isso! Guia finalizado!\nWTF?\nOK, calma, calma!\nMesmo com o bin√°rio criado, a distribui√ß√£o n√£o √© f√°cil, copiar para o servidor todas as vezes que houver uma nova atualiza√ß√£o e executar manualmente pode tornar-se complexo e chato.\nVale ressaltar que n√£o h√° uma forma consistente para a instala√ß√£o, e n√£o h√° como evitar que seja usada outra pasta no servidor, tornando o processo dif√≠cil de controlar e pass√≠vel a erros.\n2. Empacotando o bin√°rio Sabendo que a aplica√ß√£o ser√° executada em um Ubuntu Linux, temos a possibilidade de distribuir como um pacote Debian (deb), ou at√© mesmo como snap, mas neste exemplo iremos focar no Debian.\nEmpacotar como .deb nos d√° algumas vantagens, como:\nPoder controlar a vers√£o do pacote. Executar scripts antes e depois da instala√ß√£o/remo√ß√£o do pacote. Adicionar arquivos extras. Preparar um pacote Debian \u0026ldquo;na m√£o\u0026rdquo;, n√£o √© uma tarefa muito simples, e para facilitar a nossa vida vamos usar o GoReleaser, essa ferramenta maravilhosa, que internamente faz uso da √© nFPM, respons√°vel por criar pacotes Linux. Tamb√©m √© importante dizer que o GoReleaser n√£o s√≥ nos ajuda a criar os pacotes Debian, mas tamb√©m pacotes para Windows, MacOS, RPM, APK e muito mais.\nEm nosso projeto, vamos definir o arquivo .goreleaser.yaml, que cont√©m as informa√ß√µes do pacote a ser gerado, atente-se para se√ß√£o compartilhada abaixo e note que em formats foi definido o .deb:\nnfpms: - id: movies package_name: movies file_name_template: \u0026#34;{{ .ConventionalFileName }}\u0026#34; description: Manages movie collection through API license: MIT formats: - deb Adicionalmente, foi configurado o Github Workflows onde cont√©m os passos para compilar e distribuir em .deb, e o resultado √© esse:\nTodas as vers√µes criadas estar√£o em releases.\nPronto! Agora sim temos um maior controle sobre o versionamento e distribui√ß√£o da aplica√ß√£o. De maneira simples e consistente podemos instalar em qualquer distro baseada em Debian.\n3. Lidando com depend√™ncias (banco de dados em arquivo) Anteriormente foi mencionado que a aplica√ß√£o necessita de uma pasta onde o banco de dados ser√° criado, a pasta elegida ser√° em /var/lib/movies-demo, e para a cri√°-la vamos usar alguns dos hooks que pacote Debian nos fornece:\npostinst (post-install.sh): √© executado ap√≥s instalar ou atualizar um pacote, esse hook ficar√° respons√°vel por criar a pasta definida acima e tamb√©m o usu√°rio/grupo dessa pasta (√© recomend√°vel que sempre tenha um usu√°rio/grupo, ficando isolado dos demais).\n#!/bin/sh set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then # creating user and group adduser --quiet \\ --system \\ --home /nonexistent \\ --no-create-home \\ --disabled-password \\ --group \u0026#34;$MOVIES_USER\u0026#34; # creating database folder if [ ! -d $MOVIES_DB_PATH ]; then mkdir -p $MOVIES_DB_PATH chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH fi exit 0 fi Da mesma maneira que temos o postinst, tamb√©m temos um hook para quando removemos o pacote.\npostrm (post-remove-sh): √© executado quando removemos um pacote, e remover√° a pasta apenas quando o arquivo de catalog.db n√£o existir.\n#!/bin/sh set -e MOVIES_DB_PATH=/var/lib/movies-demo if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then if [ -f \u0026#34;$MOVIES_DB_PATH/catalog.db\u0026#34; ]; then echo \u0026#34;Database file found and won\u0026#39;t be removed.\u0026#34; \u0026gt;\u0026amp;2 else echo \u0026#34;Removing database folder.\u0026#34; \u0026gt;\u0026amp;2 rm -fr $MOVIES_DB_PATH fi exit 0 fi Scripts prontos, agora √© s√≥ fazer a inclus√£o deles no .goreleaser.yaml e quando empacotar e instalar a aplica√ß√£o novamente, a pasta ser√° criada:\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -46,6 +46,9 @@ nfpms: license: MIT formats: - deb + scripts: + postinstall: \u0026#34;env/debian/post-install.sh\u0026#34; + postremove: \u0026#34;env/debian/post-remove.sh\u0026#34; 4. Rodando a aplica√ß√£o em background como um servi√ßo (systemd) A pasta j√° est√° pronta, mas a execu√ß√£o pela linha de comando continua sendo manual, e para resolver essa quest√£o, vamos executar a aplica√ß√£o em background como um servi√ßo. Para isso tiraremos proveito do systemd, que j√° vem instalado no Ubuntu Linux.\nEm poucas palavras, o systemd √© um conjunto de blocos de constru√ß√£o para uma sistema Linux, ele fornece um gerenciador de sistema e servi√ßo, e √© justamente do segundo ponto que necessitamos.\nPara um servi√ßo √© requerido que seja criado um arquivo onde cont√©m as refer√™ncias para um recurso que o sistema saber√° como operar e gerenciar, chamado de unit.\nO unit que usaremos √© o service, que descreve como gerenciar um servi√ßo ou aplica√ß√£o no servidor:\nmovies.service:\n[Unit] Description=Manages movie collection through API Documentation=\u0026#34;https://github.com/faabiosr/go-movies-demo\u0026#34; [Service] EnvironmentFile=/etc/default/movies ExecStart=/usr/bin/movies Restart=on-failure User=movies-demo Group=movies-demo KillSignal=SIGINT [Install] WantedBy=multi-user.target Na se√ß√£o Service:\nEnvironmentFile: arquivo que cont√©m as vari√°veis de ambiente. ExecStart: caminho do bin√°rio. User/Group: usaremos o mesmo criado anteriormente. Precisaremos agora criar um arquivo que cont√©m a vari√°vel de ambiente usada pela aplica√ß√£o:\nmovies.conf:\nMOVIES_DB_PATH=\u0026#34;/var/lib/movies-demo\u0026#34; Uma vez finalizada a cria√ß√£o dos arquivos necess√°rios para o systemd, √© imprescind√≠vel atualizar os hooks do debian para que o mesmo seja ativado e incializado ap√≥s a instala√ß√£o:\npostint (post-install.sh): ativa o servi√ßo se n√£o foi ativo, e inicia ou reinicia caso j√° esteja rodando.\ndiff --git a/env/debian/post-install.sh b/env/debian/post-install.sh --- a/env/debian/post-install.sh +++ b/env/debian/post-install.sh @@ -4,6 +4,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo +MOVIES_SERVICE=movies.service if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then # creating user and group @@ -20,5 +21,25 @@ if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH fi - exit 0 + # enable systemd service + deb-systemd-helper unmask $MOVIES_SERVICE \u0026gt;/dev/null || true + + if deb-systemd-helper --quiet was-enabled $MOVIES_SERVICE; then + deb-systemd-helper enable $MOVIES_SERVICE \u0026gt;/dev/null || true + else + deb-systemd-helper update-state $MOVIES_SERVICE \u0026gt;/dev/null || true + fi + + # starting service + if [ -d /run/systemd/system ]; then + systemctl --system daemon-reload \u0026gt;/dev/null || true + + if [ -n \u0026#34;$2\u0026#34; ]; then + _dh_action=restart + else + _dh_action=start + fi + + deb-systemd-invoke $_dh_action $MOVIES_SERVICE \u0026gt;/dev/null || true + fi fi postrm (post-remove.sh): a nova adi√ß√£o ir√° reiniciar o servi√ßo do pr√≥prio systemd, e o servi√ßo s√≥ ser√° removido caso o usu√°rio opte por uma remo√ß√£o completa.\ndiff --git a/env/debian/post-remove.sh b/env/debian/post-remove.sh --- a/env/debian/post-remove.sh +++ b/env/debian/post-remove.sh @@ -3,6 +3,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo +MOVIES_SERVICE=movies.service if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then if [ -f \u0026#34;$MOVIES_DB_PATH/catalog.db\u0026#34; ]; then @@ -12,5 +13,16 @@ if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then rm -fr $MOVIES_DB_PATH fi - exit 0 + # disabling service + if [ -d /run/systemd/system ]; then + systemctl --system daemon-reload \u0026gt;/dev/null || true + fi + + deb-systemd-helper mask $MOVIES_SERVICE \u0026gt;/dev/null || true +fi + +if [ \u0026#34;$1\u0026#34; = \u0026#34;purge\u0026#34; ]; then + # disabling service + deb-systemd-helper purge $MOVIES_SERVICE \u0026gt;/dev/null || true + deb-systemd-helper unmask $MOVIES_SERVICE \u0026gt;/dev/null || true fi Adicionalmente criamos o prerm hook, que √© executado antes de remover o pacote, e ser√° ele respons√°vel por finalizar a execu√ß√£o da aplica√ß√£o, assim removemos o pacote de forma segura:\nprerm (pre-remove.sh):\n#!/bin/sh set -e MOVIES_SERVICE=movies.service # stopping service if [ -d /run/systemd/system ]; then deb-systemd-invoke stop $MOVIES_SERVICE \u0026gt;/dev/null || true fi Agora √© s√≥ incluir todos os arquivos no pacote Debian atualizado o .goreleaser.yaml\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -46,7 +46,14 @@ nfpms: license: MIT formats: - deb + contents: + - src: \u0026#34;env/debian/movies.service\u0026#34; + dst: \u0026#34;/lib/systemd/system/movies.service\u0026#34; + - src: \u0026#34;env/debian/movies.conf\u0026#34; + dst: \u0026#34;/etc/default/movies\u0026#34; + type: config scripts: + preremove: \u0026#34;env/debian/pre-remove.sh\u0026#34; postinstall: \u0026#34;env/debian/post-install.sh\u0026#34; postremove: \u0026#34;env/debian/post-remove.sh\u0026#34; Quando o pacote for instalado no sistema operacional, automaticamente ser√° copiado os arquivos da se√ß√£o contents para os respectivos destinos, far√° o registro no systemd e iniciar√° automaticamente.\nPoderia dizer que o empacotamento e a distribui√ß√£o do aplicativo est√° finalizado, mas ainda temos um √∫ltimo problema para ser resolvido, vejamos na √∫ltima parte.\n5. Atualiza√ß√£o e tempo de inatividade Instalar ou atualizar ficou extremamente simples e com um controle mais r√≠gido, todavia, a aplica√ß√£o pode ficar inativa durante a atualiza√ß√£o. Isso ocorre pelo simples fato de finalizar o servi√ßo e instalar uma nova vers√£o, e tendo uma degrada√ß√£o da disponibilidade.\nFelizmente, isso pode ser contornado ainda usando o systemd, atrav√©s de um outro unit, o socket. Esse arquivo de unit codifica a informa√ß√£o sobre um soquete de rede ou arquivo, controlado e supervisionado, para uma ativa√ß√£o baseada em sockets.\nVale lembrar que os unit sockets n√£o iniciam os servi√ßos por conta pr√≥pria, em vez disso, eles apenas esperam e escutam um endere√ßo IP:PORT, ou um Unix socket, e quando algo se conecta a ele, o servi√ßo ao qual o socket se destina ser√° iniciado e a conex√£o √© entregue a ele. J√° que nossa aplica√ß√£o lida com requisi√ß√µes HTTP, podemos us√°-lo.\nAlguns passos adicionais precisar√£o ser conclu√≠dos, como a cria√ß√£o e modifica√ß√£o dos units, altera√ß√£o dos hooks, e uma mudan√ßa na aplica√ß√£o, pois ela precisa suportar essa funcionalidade.\nmovies.socket:\n[Unit] Description=Manages movie collection through API Documentation=\u0026#34;https://github.com/faabiosr/go-movies-demo\u0026#34; [Socket] ListenStream=8000 SocketUser=movies-demo SocketGroup=movies-demo [Install] WantedBy=sockets.target Ali√°s, √© necess√°rio atualizar o movies.service e informar que o unit socket √© requerido:\ndiff --git a/env/debian/movies.service b/env/debian/movies.service --- a/env/debian/movies.service +++ b/env/debian/movies.service @@ -1,6 +1,8 @@ [Unit] Description=Manages movie collection through API Documentation=\u0026#34;https://github.com/faabiosr/go-movies-demo\u0026#34; +After=network.target +Requires=movies.socket [Service] EnvironmentFile=/etc/default/movies Alteramos tamb√©m os hooks do Debian:\npostinst (post-install.sh): tamb√©m far√° o registro do unit socket e s√≥ reiniciar√° o servi√ßo caso houver uma atualiza√ß√£o no pacote.\ndiff --git a/env/debian/post-install.sh b/env/debian/post-install.sh --- a/env/debian/post-install.sh +++ b/env/debian/post-install.sh @@ -5,6 +5,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo MOVIES_SERVICE=movies.service +MOVIES_SOCKET=movies.socket if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then # creating user and group @@ -30,16 +31,24 @@ if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then deb-systemd-helper update-state $MOVIES_SERVICE \u0026gt;/dev/null || true fi + # enable systemd socket + deb-systemd-helper unmask $MOVIES_SOCKET \u0026gt;/dev/null || true + + if deb-systemd-helper --quiet was-enabled $MOVIES_SOCKET; then + deb-systemd-helper enable $MOVIES_SOCKET \u0026gt;/dev/null || true + else + deb-systemd-helper update-state $MOVIES_SOCKET \u0026gt;/dev/null || true + fi + # starting service if [ -d /run/systemd/system ]; then systemctl --system daemon-reload \u0026gt;/dev/null || true if [ -n \u0026#34;$2\u0026#34; ]; then - _dh_action=restart + deb-systemd-invoke restart $MOVIES_SERVICE \u0026gt;/dev/null || true else - _dh_action=start + deb-systemd-invoke start $MOVIES_SOCKET \u0026gt;/dev/null || true fi - deb-systemd-invoke $_dh_action $MOVIES_SERVICE \u0026gt;/dev/null || true fi fi prerm (pre-remove.sh): quando seja feita uma atualiza√ß√£o, apenas o servi√ßo ser√° desligado, finalizar√° o socket, e o servi√ßo apenas na remo√ß√£o.\ndiff --git a/env/debian/pre-remove.sh b/env/debian/pre-remove.sh --- a/env/debian/pre-remove.sh +++ b/env/debian/pre-remove.sh @@ -3,8 +3,18 @@ set -e MOVIES_SERVICE=movies.service +MOVIES_SOCKET=movies.socket -# stopping service -if [ -d /run/systemd/system ]; then - deb-systemd-invoke stop $MOVIES_SERVICE \u0026gt;/dev/null || true +if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then + # stopping service and socket + if [ -d /run/systemd/system ]; then + deb-systemd-invoke stop $MOVIES_SERVICE $MOVIES_SOCKET \u0026gt;/dev/null || true + fi +fi + +if [ \u0026#34;$1\u0026#34; = \u0026#34;upgrade\u0026#34; ]; then + # stopping service + if [ -d /run/systemd/system ]; then + deb-systemd-invoke stop $MOVIES_SERVICE \u0026gt;/dev/null || true + fi fi No arquivo .goreleaser.yaml, foi inclu√≠do o arquivo .socket, na se√ß√£o contents:\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -49,6 +49,8 @@ nfpms: contents: - src: \u0026#34;env/debian/movies.service\u0026#34; dst: \u0026#34;/lib/systemd/system/movies.service\u0026#34; + - src: \u0026#34;env/debian/movies.socket\u0026#34; + dst: \u0026#34;/lib/systemd/system/movies.socket\u0026#34; - src: \u0026#34;env/debian/movies.conf\u0026#34; dst: \u0026#34;/etc/default/movies\u0026#34; type: config Independente de configurar o systemd, a aplica√ß√£o ainda n√£o est√° preparada para fazer uso de sockets, para isso vamos adicionar o suporte de ativa√ß√£o de sockets.\nA equipe do CoreOS desenvolveu o pacote go-systemd, nele cont√©m v√°rias ferramentas para integrar com o systemd, entre eles o activation.\nmain.go: inclus√£o do activation e integra√ß√£o com o servidor http.\ndiff --git a/cmd/movies/main.go b/cmd/movies/main.go --- a/cmd/movies/main.go +++ b/cmd/movies/main.go @@ -7,6 +7,7 @@ import ( \u0026#34;path/filepath\u0026#34; \u0026#34;time\u0026#34; +\t\u0026#34;github.com/coreos/go-systemd/activation\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; bolt \u0026#34;go.etcd.io/bbolt\u0026#34; @@ -46,7 +47,7 @@ func main() { e.Logger.Infof(\u0026#34;%s service\u0026#34;, appName) go func() { -\tif err := e.Start(appAddr); err != nil { +\tif err := start(e, appAddr); err != nil { e.Logger.Info(\u0026#34;shutting down the service\u0026#34;) } }() @@ -64,3 +65,16 @@ func main() { e.Logger.Fatal(err) } } + +func start(e *echo.Echo, host string) error { +\tlisteners, err := activation.Listeners() +\tif err != nil { +\treturn nil +\t} + +\tif len(listeners) \u0026gt; 0 { +\te.Listener = listeners[0] +\t} + +\treturn e.Start(host) +} Com essa parte final, a aplica√ß√£o ter√° garantias de disponibilidade durante uma reinicializa√ß√£o ou atualiza√ß√£o, e estar√° completamente funcional para distribuir.\nConclus√£o Agora n√≥s sabemos como empacotar e distribuir o aplicativo, seguindo um modelo onde podemos versionar, preparar as depend√™ncias, e garantir disponibilidade.\nAcredito que os pontos compartilhados, n√£o tem um curva de dificuldade alta, mas sim, pontos estrat√©gicos para futura manuten√ß√£o do aplicativo, tal qual, reduzir a complexidade na hora de distribuir a aplica√ß√£o, e o ponto central √© tirar proveito das ferramentas que est√£o dispon√≠veis no sistema operacional que ser√° rodado.\nA aplica√ß√£o completa usada no artigo est√° em https://github.com/faabiosr/go-movies-demo, voc√™ encontrar√° tudo l√°.\nComo prometido, aqui vai um link de cr√©ditos para brincar na Digital Ocean e criar os seus droplets.\nRecomendo a leitura das refer√™ncias abaixo para entender um pouco mais sobre o systemd, e os hooks do Debian:\nUnderstanding Systemd Units and Unit Files Systemd system and service manager deb-prerm, deb-postinst, deb-postrm ","permalink":"https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/","summary":"Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.\nA grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribui√ß√£o de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e √†s vezes preparando o bom e velho docker-compose.yaml.\nDependendo do tamanho da sua aplica√ß√£o, √†s vezes n√£o √© necess√°rio ter um cluster de Kubernetes, tamb√©m em alguns casos queremos obter todo o potencial do servidor, como mem√≥ria, disco e rede, evitando ter uma camada extra entre a aplica√ß√£o e a m√°quina.","title":"Distribuindo um aplica√ß√£o Go sem o Docker"},{"content":"Ap√≥s um longo hiato, decidi por mais uma vez tentar publicar conte√∫dos de desenvolvimento de software e outras coisinhas.\nPor diversas vezes tentar publicar artigos e dicas durante toda a minha carreira, mas infelizmente devido a falta de tempo (pois estava trabalhando demais) n√£o consegui publicar nada. Em meus antigos blogs, haviam novidades sobre os eventos que eu visitada, fotos e os bate papos que eu tinha com a galera na √©poca.\nDurante a pand√™mia de 2020-2022, por diversas vezes tentei voltar, mas n√£o foi poss√≠vel.\nEstou pensando em publicar artigos que estavam no meu antigo blog, apenas para ter um \u0026ldquo;archive\u0026rdquo; do que foi publicado, na verdade preciso encontrar os dados antes üòÑ.\nTentarei ao m√°ximo publicar apenas artigos em portugu√™s, j√° que eu vejo que a quantidade de artigos ainda n√£o √© t√£o grande em nossa l√≠ngua.\nBem, sem mais delongas, finalizo por aqui e espero que em breve tenha um artigo.\nFiquem na paz!\n","permalink":"https://fabioribeiro.dev/archive/2023/08/novo-blog/","summary":"Ap√≥s um longo hiato, decidi por mais uma vez tentar publicar conte√∫dos de desenvolvimento de software e outras coisinhas.\nPor diversas vezes tentar publicar artigos e dicas durante toda a minha carreira, mas infelizmente devido a falta de tempo (pois estava trabalhando demais) n√£o consegui publicar nada. Em meus antigos blogs, haviam novidades sobre os eventos que eu visitada, fotos e os bate papos que eu tinha com a galera na √©poca.","title":"Novo blog"}]