[{"content":"Uma vez obtida a nacionalidade espanhola, é importante que toda a sua vida documental na Espanha seja alterada. Esse processo pode ser lento em alguns casos, devido a quantidade de informações a serem alteras, agendamentos em orgãos do governo, e comunição das alterações.\nNesse pequeno/longo documento, tentarei resumir os passos que eu e minha esposa enfrentamos.\nAntes de iniciar qualquer dos processo abaixo, tenha em mãos a aplicação Cl@ave instalada, pois vários desse processos necessitam da Cl@ve, vale resaltar que alguns deles precisam do certificado digital. Eu recomendo que você faça isso o quanto antes. Eu mesmo fiz, a Cl@ve PIN, Cl@ve Permanente e o certificado digital. Evite dores de cabeça durante esse processo.\nAVISO!!! FORAM USADAS AS CL@VES E CERTIFICADO DIGITAL DO NIE!!! TENHA ISSO PARA O SEU NIE ANTES DE INICIAR OS PROCESSOS\nObtenção do DNI e passaporte Os dois documento podem ser obtidos através de uma agendamento na policia nacional, usando o seu documento atual (NIE), você consegue agendar para você e seus companhantes.\nCuerpo Nacional de Polícia: https://www.citapreviadnie.es/citaPreviaDni/\nVale lembrar que a cita online é apenas para o DNI, ouvi casos onde se pode fazer os dois ao mesmo tempo, para isso é necessário ligar no número de telefone 060. Como não sabiamos fizemos o DNI primeiro.\nUma vez com o DNI (documento mais importante de todos) em mãos, começa a grande tarefa de alterar tudo!\nCertificado de concordancia Esse documento será necessário para atualizar suas informações em outros orgãos, ou empresa onde você tem o seu NIE cadastrado, é um documento que também tem a sua importancia, mas nem sempre é utilizado para os tramites do governo.\nSegui o tutorial que se encontra nesse vídeo no Youtube: https://www.youtube.com/watch?v=Zone2vwaS14\nLink para marcar o agendamento: https://icp.administracionelectronica.gob.es/icpplustieb/index.html Formulário EX-15: https://www.inclusion.gob.es/documents/410169/2156469/15-Formulario_NIE_y_certificados.pdf Como preencher o formulário EX-15: https://www.youtube.com/watch?v=oKiNrYBu_3Y Como preencher o formulário Tasa 790-012: https://www.youtube.com/watch?v=oKiNrYBu_3Y Seguridad Social O tutorial que eu segui foi esse vídeo no Youtube: https://www.youtube.com/watch?v=ssTVwb_Do0E Um ponto importante nesse tutorial é a inclusão do Certificado de Concordancia, eu acabei não incluindo no meu processo, pois estava muito dificil o agendamento na extranjeria, e decidi incluir apenas uma cópia do NIE e DNI.\nEnviei as informações pela manhã, e no periodo da tarde, já havia recebido a confirmação do orgão, e tudo já havia cido alterado, um ponto importante, no momento que recebi a confirmação, não aparecia as informação para a Asistencia Sanitaria, só no dia seguinte da confirmação pude baixar o DOCUMENTO ACREDITATIVO DEL DERECHO A ASISTENCIA SANITARIA PÚBLICA.\nNo video compartilhado acima, é dito que o certificado de concordancia é opcional. Fizemos o tramite sem esse documento e passou. Obs.: Minha esposa alterou o sobrenome, e mesmo assim foi aceito.\nDGT (Carne de conducir) Acessando o portal Mi DGT com o certificado digital, pude fazer a alteração dos dados em Duplicado de documentación por cambio de NIE a DNI, o processo também foi simples, e no dia seguinte recebi a AUTORIZACIÓN TEMPORAL PARA CONDUCIR já com o novo DNI.\nUm ponto importante aqui é o porque eu usei o certificado digital, como eu também fiz a alteração na Agencia Tributaria, por algum motivo as informações no aplicativo Cl@ve sumiram, e a única maneira foi usando o certificado digital que eu tinha instalado no meu PC.\nCaso queira consultar se o seu novo documento foi enviado, acesse o link:\nhttps://sedeapl.dgt.gob.es/WEB_EST_PERSEO/busqueda.faces\nAgencia Tributaria Esse é um dos tramites mais importantes de todos, já que com ele toda a sua vida tributária precisa ser transferida. Nesse tramites, eu segui as recomendações desse video no Youtube https://www.youtube.com/watch?v=AaL4s_4qcl0, é explicado como preencher o documento e ir até uma oficina da Agencia Tributaria.\nUma informação importante, é que no momento de visita na Agencia Tributaria a sua nova Cl@ve vai ser ativada e também darão o código para ativação da Cl@ve Permanente.\nEm conversa com o colaborador a agencia, ele me disse que poderia já deixar preparada o Certificado Digital antes, pois assim ele já faria a validação e evitaria voltar na oficina para isso.\nFiz isso com a minha companheira, e deu certo.\nEntão recomendo que você siga os passos para obter o Certificado Digital, aqui você encontra o que é necessário: https://www.sede.fnmt.gob.es/certificados/persona-fisica/obtener-certificado-software\nTentei evitar de ir na agencia, preenchendo o modelo 030 online (usando o meu antigo certificado digital - NIE, mas infelizmente o processo não deu em nada e resolvi ir diretamente no orgão, e foi bem mais rápido que pensei).\nNo video compartilhado acima, é dito que o certificado de concordancia é opcional. Fizemos o tramite sem esse documento e passou. Obs.: Minha esposa alterou o sobrenome, e mesmo assim foi aceito.\nPadrón Muncipal - Cambio Madrid Como parte do processo, também é necessário fazer alterações no seu Empadronamiento, e para isso basta conseguir um agendamento e ir até um posto de atendimento (Não esqueça de selecionar a opção Aceso SIN Identificar, já que o seu DNI não está na base de empadronamiento ainda) https://sede.madrid.es/portal/site/tramites/menuitem.62876cb64654a55e2dbd7003a8a409a0/?vgnextoid=3e3debb41f6e2410VgnVCM2000000c205a0aRCRD\u0026amp;vgnextchannel=775ba38813180210VgnVCM100000c90da8c0RCRD\nTarjeta Sanitária Madrid Antes de ir ao seu centro de saúde, é necessário imprimir o DOCUMENTO ACREDITATIVO DEL DERECHO A ASISTENCIA SANITARIA PÚBLICA que encontra-se no porta da Seguridad Social. Agora é só apresentar esse documento, com o seu DNI e sua antiga carteira de saúde. O processo é rápido e você já sai com um documento com os novos dados, aí é só esperar o prazo indicado por eles como buscar a nova carteirinha de saúde.\nTarjeta Sanitária Européia Como agora você é um cidadão espanhol, e possui acesso via Cl@ve já pode solicitar esse novo documento, ele não é obrigatório, e pode ser interessante te-lo em caso de algum problema durante alguma viagem fora da Espanha, para solicitar, basta acessar o portal da Seguridad Social, e clicar na opção Solicitar Tarjeta\nOutros serviços Iberdrola Para alterar os dados do seu contrato de gás ou luz, recomenda-se ir a uma agência, já que nesse caso não é uma alteração de titularidade e sim de documentos. Os documentos que eu apresentei no dia foram: o DNI, e uma cópia impressa do NIE. Acredito que o Certificado de Concordancia também funcione. Após 24 horas, a atentende da agência me ligou confirmando as alterações. E já pode ser visto no aplicativo da Iberdrola.\nUm último passo é a criação de uma nova conta do aplicativo da Iberdrola, infelizmente até o momento, não é possível alterar o NIE para DNI de um usuário no aplicativo. Para solucionar o problema do usuário, foi criado um novo usando o mesmo e-mail, só que dessa vez foi colocado o DNI no lugar, e com isso automáticamente as informações dos contratos aparecem no app.\nVodafone O processo para alteração dos dados é bem complicado, fui em uma loja e os mesmos disseram que não fazem isso, já no site diz que faz. Entrei em contato por telefone e também não fazem isso na hora, para isso é necessário entrar em contato atráves do e-mail derechosprotecciondatos@vodafone.es, informando os seus dados de cadastro atual e enviar os documentos (NIE, DNI e um comprovante de endereço). Também disseram que esse processo pode demorar até 30 dias para ser concluído.\nVaculhando a internet, achei um link da própria empresa que explica como fazer, mas sem muitos detalhes.\nApós os envio da documentação, você irá receber a confirmação do recebimento, e dentro de uns dias (no meu caso 10 dias), informarão sobre a alteração e que tudo ocorreu bem.\nCom a confirmação, agora só falta criar um novo cadastro do aplicativo Mi Vodafone, clique no botão Crear usuario, preencha com os seus novos dados (DNI) e pronto.\n","permalink":"https://fabioribeiro.dev/archive/2024/11/espanha-altera%C3%A7%C3%A3o-de-nie-a-dni/","summary":"\u003cp\u003eUma vez obtida a nacionalidade espanhola, é importante que toda a sua vida documental na Espanha seja alterada. Esse processo pode ser lento em alguns casos, devido a quantidade de informações a serem alteras, agendamentos em orgãos do governo, e comunição das alterações.\u003c/p\u003e\n\u003cp\u003eNesse pequeno/longo documento, tentarei resumir os passos que eu e minha esposa enfrentamos.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAntes de iniciar qualquer dos processo abaixo, tenha em mãos a aplicação Cl@ave instalada, pois vários desse processos necessitam da Cl@ve, vale resaltar que alguns deles precisam do certificado digital. Eu recomendo que você faça isso o quanto antes. Eu mesmo fiz, a \u003ca href=\"https://clave.gob.es/clave_Home/registro/Como-puedo-registrarme.html\"\u003eCl@ve PIN\u003c/a\u003e, \u003ca href=\"https://clave.gob.es/clave_Home/Clave-Permanente/queEs.html\"\u003eCl@ve Permanente\u003c/a\u003e e o \u003ca href=\"https://www.sede.fnmt.gob.es/certificados/persona-fisica\"\u003ecertificado digital\u003c/a\u003e. Evite dores de cabeça durante esse processo.\u003c/p\u003e","title":"Espanha - Alteração de NIE a DNI"},{"content":"Quando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.\nA grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho docker-compose.yaml.\nDependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina.\nNesse artigo, apresento um compilado de como distribuir a sua aplicação para ser executada diretamente no servidor, por exemplo na sua instância AWS EC2, Google Compute Engine, e quem sabe talvez no seu droplet na Digital Ocean (no final do artigo compartilho um cupom de crédito para você brincar).\nTudo será apresentado em passos que serão incrementais, o empacotamento de uma aplicação em Golang, a preparação das dependências requeridas, a execução, e finalizamos com a atualização e tempo de inatividade.\nDe forma simplificada, uma aplicação será desenvolvida, e para cada mudança, novas tags serão criadas, e iremos focar o empacotamento e distribuição usando Ubuntu Linux (server). Ao final deixo o link onde você encontrará o projeto completo.\nA aplicação Antes de tudo, precisaremos de uma aplicação,e ela guardará os nomes dos filmes e seu dia de lançamento. Na parte que cabe ao banco de dados, eles serão armazenados em um banco de dados em arquivo, e é requerido que seja definida uma variável de ambiente chamada MOVIES_DB_PATH, onde contém a localização deste arquivo.\nVamos para a aplicação em si (de momento não se preocupe com as libs usadas, tudo estará no repositório no final do artigo):\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; bolt \u0026#34;go.etcd.io/bbolt\u0026#34; \u0026#34;github.com/faabiosr/go-movies-demo/internal/movies\u0026#34; ) const ( appAddr = \u0026#34;0.0.0.0:8000\u0026#34; appName = \u0026#34;moviez\u0026#34; dbName = \u0026#34;catalog.db\u0026#34; dbPathEnv = \u0026#34;MOVIES_DB_PATH\u0026#34; ) const timeout = 10 * time.Second func main() { e := echo.New() if os.Getenv(dbPathEnv) == \u0026#34;\u0026#34; { e.Logger.Fatalf(\u0026#34;env \u0026#39;%s\u0026#39; was not defined\u0026#34;, dbPathEnv) } dbPath := filepath.Join(os.Getenv(dbPathEnv), dbName) // Database connect db, err := bolt.Open(dbPath, 0o600, nil) if err != nil { e.Logger.Fatal(err) } ds := movies.NewDatasource(db) // API Resources movies.Routes(e.Group(\u0026#34;/movies\u0026#34;), ds) // Start server e.Logger.Infof(\u0026#34;%s service\u0026#34;, appName) go func() { if err := e.Start(appAddr); err != nil { e.Logger.Info(\u0026#34;shutting down the service\u0026#34;) } }() // Graceful shutdown quit := make(chan os.Signal, 1) signal.Notify(quit, os.Interrupt) \u0026lt;-quit ctx, cancel := context.WithTimeout(context.TODO(), timeout) defer cancel() if err := e.Shutdown(ctx); err != nil { e.Logger.Fatal(err) } } Note o ponto que informamos anteriormente, a aplicação necessita da variável de ambiente MOVIES_DB_PATH:\npackage main const ( dbName = \u0026#34;catalog.db\u0026#34; dbPathEnv = \u0026#34;MOVIES_DB_PATH\u0026#34; ) func main() { dbPath := filepath.Join(os.Getenv(dbPathEnv), dbName) // Database connect db, err := bolt.Open(dbPath, 0o600, nil) Agora que temos a aplicação de exemplo, é hora de compilar, e é bem simples, o resultado do comando abaixo será um binário com o nome de movies:\ngo build -o movies ./cmd/movies Com o binário em mãos, já podemos copiar e executar no servidor.\nMOVIES_DB_PATH=/tmp ./movies Pronto é isso! Guia finalizado!\nWTF?\nOK, calma, calma!\nMesmo com o binário criado, a distribuição não é fácil, copiar para o servidor todas as vezes que houver uma nova atualização e executar manualmente pode tornar-se complexo e chato.\nVale ressaltar que não há uma forma consistente para a instalação, e não há como evitar que seja usada outra pasta no servidor, tornando o processo difícil de controlar e passível a erros.\n2. Empacotando o binário Sabendo que a aplicação será executada em um Ubuntu Linux, temos a possibilidade de distribuir como um pacote Debian (deb), ou até mesmo como snap, mas neste exemplo iremos focar no Debian.\nEmpacotar como .deb nos dá algumas vantagens, como:\nPoder controlar a versão do pacote. Executar scripts antes e depois da instalação/remoção do pacote. Adicionar arquivos extras. Preparar um pacote Debian \u0026ldquo;na mão\u0026rdquo;, não é uma tarefa muito simples, e para facilitar a nossa vida vamos usar o GoReleaser, essa ferramenta maravilhosa, que internamente faz uso da é nFPM, responsável por criar pacotes Linux. Também é importante dizer que o GoReleaser não só nos ajuda a criar os pacotes Debian, mas também pacotes para Windows, MacOS, RPM, APK e muito mais.\nEm nosso projeto, vamos definir o arquivo .goreleaser.yaml, que contém as informações do pacote a ser gerado, atente-se para seção compartilhada abaixo e note que em formats foi definido o .deb:\nnfpms: - id: movies package_name: movies file_name_template: \u0026#34;{{ .ConventionalFileName }}\u0026#34; description: Manages movie collection through API license: MIT formats: - deb Adicionalmente, foi configurado o Github Workflows onde contém os passos para compilar e distribuir em .deb, e o resultado é esse:\nTodas as versões criadas estarão em releases.\nPronto! Agora sim temos um maior controle sobre o versionamento e distribuição da aplicação. De maneira simples e consistente podemos instalar em qualquer distro baseada em Debian.\n3. Lidando com dependências (banco de dados em arquivo) Anteriormente foi mencionado que a aplicação necessita de uma pasta onde o banco de dados será criado, a pasta elegida será em /var/lib/movies-demo, e para a criá-la vamos usar alguns dos hooks que pacote Debian nos fornece:\npostinst (post-install.sh): é executado após instalar ou atualizar um pacote, esse hook ficará responsável por criar a pasta definida acima e também o usuário/grupo dessa pasta (é recomendável que sempre tenha um usuário/grupo, ficando isolado dos demais).\n#!/bin/sh set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then # creating user and group adduser --quiet \\ --system \\ --home /nonexistent \\ --no-create-home \\ --disabled-password \\ --group \u0026#34;$MOVIES_USER\u0026#34; # creating database folder if [ ! -d $MOVIES_DB_PATH ]; then mkdir -p $MOVIES_DB_PATH chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH fi exit 0 fi Da mesma maneira que temos o postinst, também temos um hook para quando removemos o pacote.\npostrm (post-remove-sh): é executado quando removemos um pacote, e removerá a pasta apenas quando o arquivo de catalog.db não existir.\n#!/bin/sh set -e MOVIES_DB_PATH=/var/lib/movies-demo if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then if [ -f \u0026#34;$MOVIES_DB_PATH/catalog.db\u0026#34; ]; then echo \u0026#34;Database file found and won\u0026#39;t be removed.\u0026#34; \u0026gt;\u0026amp;2 else echo \u0026#34;Removing database folder.\u0026#34; \u0026gt;\u0026amp;2 rm -fr $MOVIES_DB_PATH fi exit 0 fi Scripts prontos, agora é só fazer a inclusão deles no .goreleaser.yaml e quando empacotar e instalar a aplicação novamente, a pasta será criada:\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -46,6 +46,9 @@ nfpms: license: MIT formats: - deb + scripts: + postinstall: \u0026#34;env/debian/post-install.sh\u0026#34; + postremove: \u0026#34;env/debian/post-remove.sh\u0026#34; 4. Rodando a aplicação em background como um serviço (systemd) A pasta já está pronta, mas a execução pela linha de comando continua sendo manual, e para resolver essa questão, vamos executar a aplicação em background como um serviço. Para isso tiraremos proveito do systemd, que já vem instalado no Ubuntu Linux.\nEm poucas palavras, o systemd é um conjunto de blocos de construção para uma sistema Linux, ele fornece um gerenciador de sistema e serviço, e é justamente do segundo ponto que necessitamos.\nPara um serviço é requerido que seja criado um arquivo onde contém as referências para um recurso que o sistema saberá como operar e gerenciar, chamado de unit.\nO unit que usaremos é o service, que descreve como gerenciar um serviço ou aplicação no servidor:\nmovies.service:\n[Unit] Description=Manages movie collection through API Documentation=\u0026#34;https://github.com/faabiosr/go-movies-demo\u0026#34; [Service] EnvironmentFile=/etc/default/movies ExecStart=/usr/bin/movies Restart=on-failure User=movies-demo Group=movies-demo KillSignal=SIGINT [Install] WantedBy=multi-user.target Na seção Service:\nEnvironmentFile: arquivo que contém as variáveis de ambiente. ExecStart: caminho do binário. User/Group: usaremos o mesmo criado anteriormente. Precisaremos agora criar um arquivo que contém a variável de ambiente usada pela aplicação:\nmovies.conf:\nMOVIES_DB_PATH=\u0026#34;/var/lib/movies-demo\u0026#34; Uma vez finalizada a criação dos arquivos necessários para o systemd, é imprescindível atualizar os hooks do debian para que o mesmo seja ativado e incializado após a instalação:\npostint (post-install.sh): ativa o serviço se não foi ativo, e inicia ou reinicia caso já esteja rodando.\ndiff --git a/env/debian/post-install.sh b/env/debian/post-install.sh --- a/env/debian/post-install.sh +++ b/env/debian/post-install.sh @@ -4,6 +4,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo +MOVIES_SERVICE=movies.service if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then # creating user and group @@ -20,5 +21,25 @@ if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then chown $MOVIES_USER:$MOVIES_USER $MOVIES_DB_PATH fi - exit 0 + # enable systemd service + deb-systemd-helper unmask $MOVIES_SERVICE \u0026gt;/dev/null || true + + if deb-systemd-helper --quiet was-enabled $MOVIES_SERVICE; then + deb-systemd-helper enable $MOVIES_SERVICE \u0026gt;/dev/null || true + else + deb-systemd-helper update-state $MOVIES_SERVICE \u0026gt;/dev/null || true + fi + + # starting service + if [ -d /run/systemd/system ]; then + systemctl --system daemon-reload \u0026gt;/dev/null || true + + if [ -n \u0026#34;$2\u0026#34; ]; then + _dh_action=restart + else + _dh_action=start + fi + + deb-systemd-invoke $_dh_action $MOVIES_SERVICE \u0026gt;/dev/null || true + fi fi postrm (post-remove.sh): a nova adição irá reiniciar o serviço do próprio systemd, e o serviço só será removido caso o usuário opte por uma remoção completa.\ndiff --git a/env/debian/post-remove.sh b/env/debian/post-remove.sh --- a/env/debian/post-remove.sh +++ b/env/debian/post-remove.sh @@ -3,6 +3,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo +MOVIES_SERVICE=movies.service if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then if [ -f \u0026#34;$MOVIES_DB_PATH/catalog.db\u0026#34; ]; then @@ -12,5 +13,16 @@ if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then rm -fr $MOVIES_DB_PATH fi - exit 0 + # disabling service + if [ -d /run/systemd/system ]; then + systemctl --system daemon-reload \u0026gt;/dev/null || true + fi + + deb-systemd-helper mask $MOVIES_SERVICE \u0026gt;/dev/null || true +fi + +if [ \u0026#34;$1\u0026#34; = \u0026#34;purge\u0026#34; ]; then + # disabling service + deb-systemd-helper purge $MOVIES_SERVICE \u0026gt;/dev/null || true + deb-systemd-helper unmask $MOVIES_SERVICE \u0026gt;/dev/null || true fi Adicionalmente criamos o prerm hook, que é executado antes de remover o pacote, e será ele responsável por finalizar a execução da aplicação, assim removemos o pacote de forma segura:\nprerm (pre-remove.sh):\n#!/bin/sh set -e MOVIES_SERVICE=movies.service # stopping service if [ -d /run/systemd/system ]; then deb-systemd-invoke stop $MOVIES_SERVICE \u0026gt;/dev/null || true fi Agora é só incluir todos os arquivos no pacote Debian atualizado o .goreleaser.yaml\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -46,7 +46,14 @@ nfpms: license: MIT formats: - deb + contents: + - src: \u0026#34;env/debian/movies.service\u0026#34; + dst: \u0026#34;/lib/systemd/system/movies.service\u0026#34; + - src: \u0026#34;env/debian/movies.conf\u0026#34; + dst: \u0026#34;/etc/default/movies\u0026#34; + type: config scripts: + preremove: \u0026#34;env/debian/pre-remove.sh\u0026#34; postinstall: \u0026#34;env/debian/post-install.sh\u0026#34; postremove: \u0026#34;env/debian/post-remove.sh\u0026#34; Quando o pacote for instalado no sistema operacional, automaticamente será copiado os arquivos da seção contents para os respectivos destinos, fará o registro no systemd e iniciará automaticamente.\nPoderia dizer que o empacotamento e a distribuição do aplicativo está finalizado, mas ainda temos um último problema para ser resolvido, vejamos na última parte.\n5. Atualização e tempo de inatividade Instalar ou atualizar ficou extremamente simples e com um controle mais rígido, todavia, a aplicação pode ficar inativa durante a atualização. Isso ocorre pelo simples fato de finalizar o serviço e instalar uma nova versão, e tendo uma degradação da disponibilidade.\nFelizmente, isso pode ser contornado ainda usando o systemd, através de um outro unit, o socket. Esse arquivo de unit codifica a informação sobre um soquete de rede ou arquivo, controlado e supervisionado, para uma ativação baseada em sockets.\nVale lembrar que os unit sockets não iniciam os serviços por conta própria, em vez disso, eles apenas esperam e escutam um endereço IP:PORT, ou um Unix socket, e quando algo se conecta a ele, o serviço ao qual o socket se destina será iniciado e a conexão é entregue a ele. Já que nossa aplicação lida com requisições HTTP, podemos usá-lo.\nAlguns passos adicionais precisarão ser concluídos, como a criação e modificação dos units, alteração dos hooks, e uma mudança na aplicação, pois ela precisa suportar essa funcionalidade.\nmovies.socket:\n[Unit] Description=Manages movie collection through API Documentation=\u0026#34;https://github.com/faabiosr/go-movies-demo\u0026#34; [Socket] ListenStream=8000 SocketUser=movies-demo SocketGroup=movies-demo [Install] WantedBy=sockets.target Aliás, é necessário atualizar o movies.service e informar que o unit socket é requerido:\ndiff --git a/env/debian/movies.service b/env/debian/movies.service --- a/env/debian/movies.service +++ b/env/debian/movies.service @@ -1,6 +1,8 @@ [Unit] Description=Manages movie collection through API Documentation=\u0026#34;https://github.com/faabiosr/go-movies-demo\u0026#34; +After=network.target +Requires=movies.socket [Service] EnvironmentFile=/etc/default/movies Alteramos também os hooks do Debian:\npostinst (post-install.sh): também fará o registro do unit socket e só reiniciará o serviço caso houver uma atualização no pacote.\ndiff --git a/env/debian/post-install.sh b/env/debian/post-install.sh --- a/env/debian/post-install.sh +++ b/env/debian/post-install.sh @@ -5,6 +5,7 @@ set -e MOVIES_DB_PATH=/var/lib/movies-demo MOVIES_USER=movies-demo MOVIES_SERVICE=movies.service +MOVIES_SOCKET=movies.socket if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then # creating user and group @@ -30,16 +31,24 @@ if [ \u0026#34;$1\u0026#34; = \u0026#34;configure\u0026#34; ]; then deb-systemd-helper update-state $MOVIES_SERVICE \u0026gt;/dev/null || true fi + # enable systemd socket + deb-systemd-helper unmask $MOVIES_SOCKET \u0026gt;/dev/null || true + + if deb-systemd-helper --quiet was-enabled $MOVIES_SOCKET; then + deb-systemd-helper enable $MOVIES_SOCKET \u0026gt;/dev/null || true + else + deb-systemd-helper update-state $MOVIES_SOCKET \u0026gt;/dev/null || true + fi + # starting service if [ -d /run/systemd/system ]; then systemctl --system daemon-reload \u0026gt;/dev/null || true if [ -n \u0026#34;$2\u0026#34; ]; then - _dh_action=restart + deb-systemd-invoke restart $MOVIES_SERVICE \u0026gt;/dev/null || true else - _dh_action=start + deb-systemd-invoke start $MOVIES_SOCKET \u0026gt;/dev/null || true fi - deb-systemd-invoke $_dh_action $MOVIES_SERVICE \u0026gt;/dev/null || true fi fi prerm (pre-remove.sh): quando seja feita uma atualização, apenas o serviço será desligado, finalizará o socket, e o serviço apenas na remoção.\ndiff --git a/env/debian/pre-remove.sh b/env/debian/pre-remove.sh --- a/env/debian/pre-remove.sh +++ b/env/debian/pre-remove.sh @@ -3,8 +3,18 @@ set -e MOVIES_SERVICE=movies.service +MOVIES_SOCKET=movies.socket -# stopping service -if [ -d /run/systemd/system ]; then - deb-systemd-invoke stop $MOVIES_SERVICE \u0026gt;/dev/null || true +if [ \u0026#34;$1\u0026#34; = \u0026#34;remove\u0026#34; ]; then + # stopping service and socket + if [ -d /run/systemd/system ]; then + deb-systemd-invoke stop $MOVIES_SERVICE $MOVIES_SOCKET \u0026gt;/dev/null || true + fi +fi + +if [ \u0026#34;$1\u0026#34; = \u0026#34;upgrade\u0026#34; ]; then + # stopping service + if [ -d /run/systemd/system ]; then + deb-systemd-invoke stop $MOVIES_SERVICE \u0026gt;/dev/null || true + fi fi No arquivo .goreleaser.yaml, foi incluído o arquivo .socket, na seção contents:\ndiff --git a/.goreleaser.yaml b/.goreleaser.yaml --- a/.goreleaser.yaml +++ b/.goreleaser.yaml @@ -49,6 +49,8 @@ nfpms: contents: - src: \u0026#34;env/debian/movies.service\u0026#34; dst: \u0026#34;/lib/systemd/system/movies.service\u0026#34; + - src: \u0026#34;env/debian/movies.socket\u0026#34; + dst: \u0026#34;/lib/systemd/system/movies.socket\u0026#34; - src: \u0026#34;env/debian/movies.conf\u0026#34; dst: \u0026#34;/etc/default/movies\u0026#34; type: config Independente de configurar o systemd, a aplicação ainda não está preparada para fazer uso de sockets, para isso vamos adicionar o suporte de ativação de sockets.\nA equipe do CoreOS desenvolveu o pacote go-systemd, nele contém várias ferramentas para integrar com o systemd, entre eles o activation.\nmain.go: inclusão do activation e integração com o servidor http.\ndiff --git a/cmd/movies/main.go b/cmd/movies/main.go --- a/cmd/movies/main.go +++ b/cmd/movies/main.go @@ -7,6 +7,7 @@ import ( \u0026#34;path/filepath\u0026#34; \u0026#34;time\u0026#34; +\t\u0026#34;github.com/coreos/go-systemd/activation\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; bolt \u0026#34;go.etcd.io/bbolt\u0026#34; @@ -46,7 +47,7 @@ func main() { e.Logger.Infof(\u0026#34;%s service\u0026#34;, appName) go func() { -\tif err := e.Start(appAddr); err != nil { +\tif err := start(e, appAddr); err != nil { e.Logger.Info(\u0026#34;shutting down the service\u0026#34;) } }() @@ -64,3 +65,16 @@ func main() { e.Logger.Fatal(err) } } + +func start(e *echo.Echo, host string) error { +\tlisteners, err := activation.Listeners() +\tif err != nil { +\treturn nil +\t} + +\tif len(listeners) \u0026gt; 0 { +\te.Listener = listeners[0] +\t} + +\treturn e.Start(host) +} Com essa parte final, a aplicação terá garantias de disponibilidade durante uma reinicialização ou atualização, e estará completamente funcional para distribuir.\nConclusão Agora nós sabemos como empacotar e distribuir o aplicativo, seguindo um modelo onde podemos versionar, preparar as dependências, e garantir disponibilidade.\nAcredito que os pontos compartilhados, não tem um curva de dificuldade alta, mas sim, pontos estratégicos para futura manutenção do aplicativo, tal qual, reduzir a complexidade na hora de distribuir a aplicação, e o ponto central é tirar proveito das ferramentas que estão disponíveis no sistema operacional que será rodado.\nA aplicação completa usada no artigo está em https://github.com/faabiosr/go-movies-demo, você encontrará tudo lá.\nComo prometido, aqui vai um link de créditos para brincar na Digital Ocean e criar os seus droplets.\nRecomendo a leitura das referências abaixo para entender um pouco mais sobre o systemd, e os hooks do Debian:\nUnderstanding Systemd Units and Unit Files Systemd system and service manager deb-prerm, deb-postinst, deb-postrm ","permalink":"https://fabioribeiro.dev/archive/2023/10/distribuindo-um-aplica%C3%A7%C3%A3o-go-sem-o-docker/","summary":"\u003cp\u003eQuando pensamos em escalabilidade de software, invariavelmente, em alguma eventualidade nos deparamos com a necessidade de distribuir nosso software.\u003c/p\u003e\n\u003cp\u003eA grande maioria dos artigos e tutoriais que encontramos e que falam sobre distribuição de software, acabam descrevendo sobre como distribuir usando Kubernetes, Docker Swarm e às vezes preparando o bom e velho \u003ccode\u003edocker-compose.yaml\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eDependendo do tamanho da sua aplicação, às vezes não é necessário ter um cluster de Kubernetes, também em alguns casos queremos obter todo o potencial do servidor, como memória, disco e rede, evitando ter uma camada extra entre a aplicação e a máquina.\u003c/p\u003e","title":"Distribuindo um aplicação Go sem o Docker"},{"content":"Após um longo hiato, decidi por mais uma vez tentar publicar conteúdos de desenvolvimento de software e outras coisinhas.\nPor diversas vezes tentar publicar artigos e dicas durante toda a minha carreira, mas infelizmente devido a falta de tempo (pois estava trabalhando demais) não consegui publicar nada. Em meus antigos blogs, haviam novidades sobre os eventos que eu visitada, fotos e os bate papos que eu tinha com a galera na época.\nDurante a pandêmia de 2020-2022, por diversas vezes tentei voltar, mas não foi possível.\nEstou pensando em publicar artigos que estavam no meu antigo blog, apenas para ter um \u0026ldquo;archive\u0026rdquo; do que foi publicado, na verdade preciso encontrar os dados antes \u0026#x1f604;.\nTentarei ao máximo publicar apenas artigos em português, já que eu vejo que a quantidade de artigos ainda não é tão grande em nossa língua.\nBem, sem mais delongas, finalizo por aqui e espero que em breve tenha um artigo.\nFiquem na paz!\n","permalink":"https://fabioribeiro.dev/archive/2023/08/novo-blog/","summary":"\u003cp\u003eApós um longo hiato, decidi por mais uma vez tentar publicar conteúdos de desenvolvimento de software e outras coisinhas.\u003c/p\u003e\n\u003cp\u003ePor diversas vezes tentar publicar artigos e dicas durante toda a minha carreira, mas infelizmente devido a falta de tempo (pois estava trabalhando demais) não consegui publicar nada. Em meus antigos blogs, haviam novidades sobre os eventos que eu visitada, fotos e os bate papos que eu tinha com a galera na época.\u003c/p\u003e","title":"Novo blog"}]